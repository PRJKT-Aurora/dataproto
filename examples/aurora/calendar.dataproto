// DataProto schema for Aurora Calendar
// This schema generates both wire format (protobuf) and storage format (SQL)

package acos;

// Calendar event entity
// Maps to: calendar_events table + CalendarEvent proto message
@table("calendar_events")
@backends(sqlite, postgres)
entity CalendarEvent {
    // Primary key - unique event identifier
    @pk
    id: string;

    // Event title (required)
    @required
    title: string;

    // Start time as epoch milliseconds
    @indexed
    @required
    start_date: timestamp;

    // End time as epoch milliseconds (optional for all-day events)
    end_date: timestamp?;

    // Whether this is an all-day event
    @default(false)
    is_all_day: bool;

    // Hex color code for the calendar (e.g., "#FF5733")
    @pattern("^#[0-9A-Fa-f]{6}$")
    calendar_color: string?;

    // Name of the calendar this event belongs to
    calendar_name: string?;

    // Event location
    location: string?;

    // Additional notes
    @length(max: 5000)
    notes: string?;

    // Number of attachments (denormalized for quick access)
    @default(0)
    attachment_count: int32;

    // Query: Get events in a date range
    query eventsByDateRange(after: timestamp, before: timestamp) {
        where start_date >= after AND start_date < before
        order_by start_date ASC
    }

    // Query: Get upcoming events
    query upcomingEvents(limit: int32 = 50) {
        where start_date >= NOW()
        order_by start_date ASC
        limit limit
    }

    // Query: Get events for a specific calendar
    query eventsByCalendar(calendarName: string) {
        where calendar_name = calendarName
        order_by start_date ASC
    }

    // Query: Search events by title or notes
    query searchEvents(term: string) {
        where title LIKE "%" || term || "%"
           OR notes LIKE "%" || term || "%"
        order_by start_date DESC
    }
}

// Attachment entity for event files (flyers, PDFs, documents)
// Stored separately to keep CalendarEvent lightweight
@table("event_attachments")
@backends(sqlite, postgres)
entity EventAttachment {
    // Primary key - unique attachment identifier
    @pk
    id: string;

    // Foreign key to CalendarEvent
    @indexed
    @required
    event_id: string;

    // Original filename
    @required
    file_name: string;

    // MIME type (e.g., "application/pdf", "image/jpeg")
    @required
    mime_type: string;

    // File size in bytes
    @required
    size_bytes: int64;

    // When the attachment was added
    @required
    created_at: timestamp;

    // Binary data for small files (< 1MB inline, larger use storage_path)
    // NULL if stored externally
    @length(max: 1048576)  // 1MB limit for inline storage
    data: bytes?;

    // External storage path for large files
    // Format: "attachments/{event_id}/{id}.{ext}"
    storage_path: string?;

    // Thumbnail for images/PDFs (optional, for quick preview)
    @length(max: 65536)  // 64KB limit for thumbnails
    thumbnail: bytes?;

    // Query: Get all attachments for an event
    query attachmentsForEvent(eventId: string) {
        where event_id = eventId
        order_by created_at ASC
    }
}

// Request/response messages for gRPC
service CalendarService {
    // Push events from client (iPhone) to server
    rpc PushEvents(stream CalendarEvent) returns (PushResult);

    // Get events from server
    rpc GetEvents(GetEventsRequest) returns (stream CalendarEvent);

    // Delete an event by ID
    rpc DeleteEvent(DeleteEventRequest) returns (Result);

    // Clear all events (for sync reset)
    rpc ClearEvents(ClearEventsRequest) returns (Result);

    // Upload an attachment for an event
    rpc UploadAttachment(stream AttachmentChunk) returns (UploadAttachmentResult);

    // Get attachment metadata for an event
    rpc GetAttachments(GetAttachmentsRequest) returns (stream EventAttachment);

    // Download attachment data
    rpc DownloadAttachment(DownloadAttachmentRequest) returns (stream AttachmentChunk);

    // Delete an attachment
    rpc DeleteAttachment(DeleteAttachmentRequest) returns (Result);
}
