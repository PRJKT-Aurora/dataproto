package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// SQLiteGenerator generates SQLite DDL from DataProto schemas.
type SQLiteGenerator struct {
	// IncludeDropStatements adds DROP TABLE IF EXISTS before CREATE
	IncludeDropStatements bool
}

// NewSQLiteGenerator creates a new SQLiteGenerator.
func NewSQLiteGenerator() *SQLiteGenerator {
	return &SQLiteGenerator{}
}

// Generate generates SQLite DDL from a DataProto file.
func (g *SQLiteGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	var sb strings.Builder

	// Header
	sb.WriteString("-- Code generated by dataprotoc. DO NOT EDIT.\n")
	sb.WriteString("-- source: ")
	if file.Package != nil {
		sb.WriteString(file.Package.Name)
	}
	sb.WriteString(".dataproto\n\n")

	// Generate tables for each entity
	for _, entity := range file.Entities {
		// Check if sqlite is a supported backend
		backends := entity.Backends()
		if len(backends) > 0 {
			supported := false
			for _, b := range backends {
				if b == "sqlite" {
					supported = true
					break
				}
			}
			if !supported {
				continue
			}
		}

		tableDDL, err := g.generateTable(entity)
		if err != nil {
			return nil, err
		}
		sb.WriteString(tableDDL)
		sb.WriteString("\n")

		// Generate indexes
		indexes := g.generateIndexes(entity)
		sb.WriteString(indexes)
		if indexes != "" {
			sb.WriteString("\n")
		}
	}

	// Generate filename
	filename := "schema.sql"
	if file.Package != nil {
		parts := strings.Split(file.Package.Name, ".")
		filename = parts[len(parts)-1] + "_schema.sql"
	}

	result[filename] = sb.String()
	return result, nil
}

func (g *SQLiteGenerator) generateTable(entity *parser.EntityDecl) (string, error) {
	var sb strings.Builder

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	if g.IncludeDropStatements {
		sb.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS %s;\n\n", tableName))
	}

	sb.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", tableName))

	var columns []string
	var uniqueConstraints []string
	var foreignKeys []string

	for _, field := range entity.Fields {
		colDef := g.generateColumn(field)
		columns = append(columns, "    "+colDef)

		if field.IsUnique() && !field.IsPrimaryKey() {
			uniqueConstraints = append(uniqueConstraints,
				fmt.Sprintf("    UNIQUE (%s)", ToSnakeCase(field.Name)))
		}

		// Check for foreign key
		if fk := field.GetAnnotation("fk"); fk != nil && len(fk.Args) > 0 {
			if ref, ok := fk.Args[0].Value.(string); ok {
				// Parse Entity.field format
				parts := strings.Split(ref, ".")
				if len(parts) == 2 {
					refTable := ToSnakeCase(parts[0])
					refColumn := ToSnakeCase(parts[1])

					onDelete := "RESTRICT"
					if od := field.GetAnnotation("ondelete"); od != nil && len(od.Args) > 0 {
						if action, ok := od.Args[0].Value.(string); ok {
							switch strings.ToLower(action) {
							case "cascade":
								onDelete = "CASCADE"
							case "setnull":
								onDelete = "SET NULL"
							case "restrict":
								onDelete = "RESTRICT"
							}
						}
					}

					foreignKeys = append(foreignKeys,
						fmt.Sprintf("    FOREIGN KEY (%s) REFERENCES %s(%s) ON DELETE %s",
							ToSnakeCase(field.Name), refTable, refColumn, onDelete))
				}
			}
		}
	}

	// Build full DDL
	allConstraints := append(columns, uniqueConstraints...)
	allConstraints = append(allConstraints, foreignKeys...)

	sb.WriteString(strings.Join(allConstraints, ",\n"))
	sb.WriteString("\n);\n")

	return sb.String(), nil
}

func (g *SQLiteGenerator) generateColumn(field *parser.FieldDecl) string {
	colName := ToSnakeCase(field.Name)
	typeMapping := GetTypeMapping(field.Type.Name)
	sqlType := typeMapping.SQLite

	var constraints []string

	// Primary key
	if field.IsPrimaryKey() {
		constraints = append(constraints, "PRIMARY KEY")
	}

	// NOT NULL (unless optional or has default)
	if !field.Type.Optional && field.GetAnnotation("default") == nil && !field.IsPrimaryKey() {
		if field.IsRequired() {
			constraints = append(constraints, "NOT NULL")
		}
	}

	// Default value
	if def := field.GetAnnotation("default"); def != nil && len(def.Args) > 0 {
		defaultVal := g.formatDefaultValue(def.Args[0].Value, field.Type.Name)
		constraints = append(constraints, fmt.Sprintf("DEFAULT %s", defaultVal))
	}

	if len(constraints) > 0 {
		return fmt.Sprintf("%s %s %s", colName, sqlType, strings.Join(constraints, " "))
	}
	return fmt.Sprintf("%s %s", colName, sqlType)
}

func (g *SQLiteGenerator) formatDefaultValue(value interface{}, typeName string) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))
	case bool:
		if v {
			return "1"
		}
		return "0"
	case int64:
		return fmt.Sprintf("%d", v)
	case float64:
		return fmt.Sprintf("%f", v)
	default:
		return "NULL"
	}
}

func (g *SQLiteGenerator) generateIndexes(entity *parser.EntityDecl) string {
	var sb strings.Builder

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	for _, field := range entity.Fields {
		if field.IsIndexed() && !field.IsPrimaryKey() {
			colName := ToSnakeCase(field.Name)
			indexName := fmt.Sprintf("idx_%s_%s", tableName, colName)

			sb.WriteString(fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s\n    ON %s(%s);\n",
				indexName, tableName, colName))
		}
	}

	return sb.String()
}

// GenerateMigration generates a migration from one schema version to another.
func (g *SQLiteGenerator) GenerateMigration(from, to *parser.EntityDecl) (string, error) {
	var sb strings.Builder

	tableName := to.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(to.Name)
	}

	// Build field maps
	fromFields := make(map[string]*parser.FieldDecl)
	if from != nil {
		for _, f := range from.Fields {
			fromFields[f.Name] = f
		}
	}

	toFields := make(map[string]*parser.FieldDecl)
	for _, f := range to.Fields {
		toFields[f.Name] = f
	}

	sb.WriteString(fmt.Sprintf("-- Migration for table: %s\n\n", tableName))

	// Find added columns
	for name, field := range toFields {
		if _, exists := fromFields[name]; !exists {
			colDef := g.generateColumn(field)
			sb.WriteString(fmt.Sprintf("ALTER TABLE %s ADD COLUMN %s;\n",
				tableName, colDef))
		}
	}

	// Find removed columns (SQLite doesn't support DROP COLUMN in older versions)
	var droppedCols []string
	for name := range fromFields {
		if _, exists := toFields[name]; !exists {
			droppedCols = append(droppedCols, name)
		}
	}

	if len(droppedCols) > 0 {
		sb.WriteString("\n-- Note: SQLite requires table recreation to drop columns.\n")
		sb.WriteString(fmt.Sprintf("-- Columns to remove: %s\n", strings.Join(droppedCols, ", ")))
		sb.WriteString("-- Use the following approach:\n")
		sb.WriteString("-- 1. CREATE TABLE new_table AS SELECT ... FROM old_table\n")
		sb.WriteString("-- 2. DROP TABLE old_table\n")
		sb.WriteString("-- 3. ALTER TABLE new_table RENAME TO old_table\n")
	}

	return sb.String(), nil
}
