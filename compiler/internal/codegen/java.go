package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// JavaGenerator generates Java code from DataProto schemas.
type JavaGenerator struct {
	PackageName         string // Java package name
	RuntimePackage      string // DataProto runtime package
	UseCertification    bool   // Include certification check
	GenerateBuilders    bool   // Generate builder pattern
	GenerateMappers     bool   // Generate proto<->entity mappers
	GenerateRepository  bool   // Generate repository classes
}

// NewJavaGenerator creates a new JavaGenerator with defaults.
func NewJavaGenerator() *JavaGenerator {
	return &JavaGenerator{
		RuntimePackage:     "dev.dataproto",
		UseCertification:   true,
		GenerateBuilders:   true,
		GenerateMappers:    true,
		GenerateRepository: true,
	}
}

// Generate generates Java code from a DataProto file.
func (g *JavaGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	// Set package name from file
	if file.Package != nil && g.PackageName == "" {
		g.PackageName = file.Package.Name
	}

	// Generate code for each entity
	for _, entity := range file.Entities {
		// Repository class
		if g.GenerateRepository {
			repoCode := g.generateRepository(entity)
			filename := entity.Name + "Repository.java"
			result[filename] = repoCode
		}

		// Mapper class
		if g.GenerateMappers {
			mapperCode := g.generateMapper(entity)
			filename := entity.Name + "Mapper.java"
			result[filename] = mapperCode
		}
	}

	return result, nil
}

func (g *JavaGenerator) generateRepository(entity *parser.EntityDecl) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")

	// Package
	if g.PackageName != "" {
		sb.WriteString(fmt.Sprintf("package %s;\n\n", g.PackageName))
	}

	// Imports
	sb.WriteString("import java.sql.*;\n")
	sb.WriteString("import java.util.ArrayList;\n")
	sb.WriteString("import java.util.List;\n")
	sb.WriteString("import java.util.Optional;\n")
	if g.UseCertification {
		sb.WriteString(fmt.Sprintf("import %s.DataProtoRuntime;\n", g.RuntimePackage))
	}
	sb.WriteString("\n")

	// Class
	sb.WriteString(fmt.Sprintf("public class %sRepository {\n\n", entity.Name))

	// Fields
	sb.WriteString("    private final DataProtoRuntime runtime;\n\n")

	// Constructor
	sb.WriteString(fmt.Sprintf("    public %sRepository(DataProtoRuntime runtime) {\n", entity.Name))
	if g.UseCertification {
		sb.WriteString("        runtime.requireCertified(); // HARD ENFORCEMENT\n")
	}
	sb.WriteString("        this.runtime = runtime;\n")
	sb.WriteString("    }\n\n")

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	// Generate CRUD methods
	sb.WriteString(g.generateUpsert(entity, tableName))
	sb.WriteString(g.generateFindById(entity, tableName))
	sb.WriteString(g.generateFindAll(entity, tableName))
	sb.WriteString(g.generateDelete(entity, tableName))

	// Generate query methods
	for _, query := range entity.Queries {
		sb.WriteString(g.generateQueryMethod(entity, query, tableName))
	}

	// Generate row mapper
	sb.WriteString(g.generateRowMapper(entity))

	sb.WriteString("}\n")

	return sb.String()
}

func (g *JavaGenerator) generateUpsert(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	// Build column list
	var columns []string
	var placeholders []string
	var setters []string

	for _, field := range entity.Fields {
		colName := ToSnakeCase(field.Name)
		columns = append(columns, colName)
		placeholders = append(placeholders, "?")
	}

	sb.WriteString(fmt.Sprintf("    public void upsert(%s entity) {\n", entity.Name))
	sb.WriteString("        String sql = \"INSERT OR REPLACE INTO ")
	sb.WriteString(tableName)
	sb.WriteString(" (")
	sb.WriteString(strings.Join(columns, ", "))
	sb.WriteString(") VALUES (")
	sb.WriteString(strings.Join(placeholders, ", "))
	sb.WriteString(")\";\n\n")

	sb.WriteString("        try (Connection conn = runtime.getConnection();\n")
	sb.WriteString("             PreparedStatement stmt = conn.prepareStatement(sql)) {\n")

	for i, field := range entity.Fields {
		setter := g.getJavaSetter(field, i+1)
		setters = append(setters, setter)
		sb.WriteString(fmt.Sprintf("            %s\n", setter))
	}

	sb.WriteString("            stmt.executeUpdate();\n")
	sb.WriteString("        } catch (SQLException e) {\n")
	sb.WriteString("            throw new RuntimeException(\"Failed to upsert \" + entity, e);\n")
	sb.WriteString("        }\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *JavaGenerator) generateFindById(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	// Find primary key field
	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}

	if pkField == nil {
		return ""
	}

	pkType := GetTypeMapping(pkField.Type.Name).Java
	pkName := ToCamelCase(pkField.Name)
	pkCol := ToSnakeCase(pkField.Name)

	sb.WriteString(fmt.Sprintf("    public Optional<%s> findById(%s %s) {\n",
		entity.Name, pkType, pkName))
	sb.WriteString(fmt.Sprintf("        String sql = \"SELECT * FROM %s WHERE %s = ?\";\n\n",
		tableName, pkCol))

	sb.WriteString("        try (Connection conn = runtime.getConnection();\n")
	sb.WriteString("             PreparedStatement stmt = conn.prepareStatement(sql)) {\n")
	sb.WriteString(fmt.Sprintf("            stmt.%s(1, %s);\n",
		g.getPreparedStatementMethod(pkField.Type.Name), pkName))
	sb.WriteString("            try (ResultSet rs = stmt.executeQuery()) {\n")
	sb.WriteString("                if (rs.next()) {\n")
	sb.WriteString("                    return Optional.of(mapRow(rs));\n")
	sb.WriteString("                }\n")
	sb.WriteString("                return Optional.empty();\n")
	sb.WriteString("            }\n")
	sb.WriteString("        } catch (SQLException e) {\n")
	sb.WriteString(fmt.Sprintf("            throw new RuntimeException(\"Failed to find by id: \" + %s, e);\n", pkName))
	sb.WriteString("        }\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *JavaGenerator) generateFindAll(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("    public List<%s> findAll() {\n", entity.Name))
	sb.WriteString(fmt.Sprintf("        String sql = \"SELECT * FROM %s\";\n", tableName))
	sb.WriteString(fmt.Sprintf("        List<%s> results = new ArrayList<>();\n\n", entity.Name))

	sb.WriteString("        try (Connection conn = runtime.getConnection();\n")
	sb.WriteString("             PreparedStatement stmt = conn.prepareStatement(sql);\n")
	sb.WriteString("             ResultSet rs = stmt.executeQuery()) {\n")
	sb.WriteString("            while (rs.next()) {\n")
	sb.WriteString("                results.add(mapRow(rs));\n")
	sb.WriteString("            }\n")
	sb.WriteString("        } catch (SQLException e) {\n")
	sb.WriteString("            throw new RuntimeException(\"Failed to find all\", e);\n")
	sb.WriteString("        }\n")
	sb.WriteString("        return results;\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *JavaGenerator) generateDelete(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	// Find primary key field
	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}

	if pkField == nil {
		return ""
	}

	pkType := GetTypeMapping(pkField.Type.Name).Java
	pkName := ToCamelCase(pkField.Name)
	pkCol := ToSnakeCase(pkField.Name)

	sb.WriteString(fmt.Sprintf("    public boolean delete(%s %s) {\n", pkType, pkName))
	sb.WriteString(fmt.Sprintf("        String sql = \"DELETE FROM %s WHERE %s = ?\";\n\n",
		tableName, pkCol))

	sb.WriteString("        try (Connection conn = runtime.getConnection();\n")
	sb.WriteString("             PreparedStatement stmt = conn.prepareStatement(sql)) {\n")
	sb.WriteString(fmt.Sprintf("            stmt.%s(1, %s);\n",
		g.getPreparedStatementMethod(pkField.Type.Name), pkName))
	sb.WriteString("            return stmt.executeUpdate() > 0;\n")
	sb.WriteString("        } catch (SQLException e) {\n")
	sb.WriteString(fmt.Sprintf("            throw new RuntimeException(\"Failed to delete: \" + %s, e);\n", pkName))
	sb.WriteString("        }\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *JavaGenerator) generateQueryMethod(entity *parser.EntityDecl, query *parser.QueryDecl, tableName string) string {
	var sb strings.Builder

	// Method signature
	sb.WriteString(fmt.Sprintf("    public List<%s> %s(", entity.Name, ToCamelCase(query.Name)))

	// Parameters
	var params []string
	for _, p := range query.Params {
		javaType := GetTypeMapping(p.Type.Name).Java
		if p.Type.Optional || p.Default != nil {
			// Use wrapper type for optional
			javaType = g.getWrapperType(javaType)
		}
		params = append(params, fmt.Sprintf("%s %s", javaType, ToCamelCase(p.Name)))
	}
	sb.WriteString(strings.Join(params, ", "))
	sb.WriteString(") {\n")

	// Build set of known parameter names
	knownParams := make(map[string]bool)
	for _, p := range query.Params {
		knownParams[p.Name] = true
	}

	// Build SQL
	var sqlParts []string
	sqlParts = append(sqlParts, fmt.Sprintf("SELECT * FROM %s", tableName))

	// WHERE clause
	if query.Where != nil {
		whereSQL, paramNames := ExprToSQLWithKnownParams(query.Where, knownParams)
		sqlParts = append(sqlParts, "WHERE "+whereSQL)
		_ = paramNames // Used for parameter binding order
	}

	// ORDER BY
	if len(query.OrderBy) > 0 {
		var orderParts []string
		for _, o := range query.OrderBy {
			dir := "ASC"
			if o.Descending {
				dir = "DESC"
			}
			orderParts = append(orderParts, fmt.Sprintf("%s %s", ToSnakeCase(o.Field), dir))
		}
		sqlParts = append(sqlParts, "ORDER BY "+strings.Join(orderParts, ", "))
	}

	// LIMIT
	if query.Limit != nil {
		switch l := query.Limit.(type) {
		case *parser.LiteralExpr:
			if val, ok := l.Value.(int64); ok {
				sqlParts = append(sqlParts, fmt.Sprintf("LIMIT %d", val))
			}
		case *parser.IdentExpr:
			sqlParts = append(sqlParts, "LIMIT ?")
		}
	}

	sb.WriteString(fmt.Sprintf("        String sql = \"%s\";\n", strings.Join(sqlParts, " ")))
	sb.WriteString(fmt.Sprintf("        List<%s> results = new ArrayList<>();\n\n", entity.Name))

	sb.WriteString("        try (Connection conn = runtime.getConnection();\n")
	sb.WriteString("             PreparedStatement stmt = conn.prepareStatement(sql)) {\n")

	// Bind parameters
	paramIdx := 1
	for _, p := range query.Params {
		setter := g.getPreparedStatementMethod(p.Type.Name)
		sb.WriteString(fmt.Sprintf("            stmt.%s(%d, %s);\n",
			setter, paramIdx, ToCamelCase(p.Name)))
		paramIdx++
	}

	// Handle limit if it's a parameter
	if query.Limit != nil {
		if l, ok := query.Limit.(*parser.IdentExpr); ok {
			sb.WriteString(fmt.Sprintf("            stmt.setInt(%d, %s);\n",
				paramIdx, ToCamelCase(l.Name)))
		}
	}

	sb.WriteString("            try (ResultSet rs = stmt.executeQuery()) {\n")
	sb.WriteString("                while (rs.next()) {\n")
	sb.WriteString("                    results.add(mapRow(rs));\n")
	sb.WriteString("                }\n")
	sb.WriteString("            }\n")
	sb.WriteString("        } catch (SQLException e) {\n")
	sb.WriteString(fmt.Sprintf("            throw new RuntimeException(\"Failed to execute %s\", e);\n",
		query.Name))
	sb.WriteString("        }\n")
	sb.WriteString("        return results;\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *JavaGenerator) generateRowMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("    private %s mapRow(ResultSet rs) throws SQLException {\n", entity.Name))

	if g.GenerateBuilders {
		sb.WriteString(fmt.Sprintf("        return %s.newBuilder()\n", entity.Name))
		for _, field := range entity.Fields {
			getter := g.getResultSetGetter(field)
			setterName := "set" + ToPascalCase(field.Name)
			sb.WriteString(fmt.Sprintf("            .%s(%s)\n", setterName, getter))
		}
		sb.WriteString("            .build();\n")
	} else {
		sb.WriteString(fmt.Sprintf("        %s entity = new %s();\n", entity.Name, entity.Name))
		for _, field := range entity.Fields {
			getter := g.getResultSetGetter(field)
			setterName := "set" + ToPascalCase(field.Name)
			sb.WriteString(fmt.Sprintf("        entity.%s(%s);\n", setterName, getter))
		}
		sb.WriteString("        return entity;\n")
	}

	sb.WriteString("    }\n")

	return sb.String()
}

func (g *JavaGenerator) generateMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")

	if g.PackageName != "" {
		sb.WriteString(fmt.Sprintf("package %s;\n\n", g.PackageName))
	}

	sb.WriteString(fmt.Sprintf("public class %sMapper {\n\n", entity.Name))

	// Proto to Entity
	sb.WriteString(fmt.Sprintf("    public static %s fromProto(%sProto proto) {\n",
		entity.Name, entity.Name))

	if g.GenerateBuilders {
		sb.WriteString(fmt.Sprintf("        return %s.newBuilder()\n", entity.Name))
		for _, field := range entity.Fields {
			protoGetter := "get" + ToPascalCase(field.Name) + "()"
			setter := "set" + ToPascalCase(field.Name)
			sb.WriteString(fmt.Sprintf("            .%s(proto.%s)\n", setter, protoGetter))
		}
		sb.WriteString("            .build();\n")
	} else {
		sb.WriteString(fmt.Sprintf("        %s entity = new %s();\n", entity.Name, entity.Name))
		for _, field := range entity.Fields {
			protoGetter := "get" + ToPascalCase(field.Name) + "()"
			setter := "set" + ToPascalCase(field.Name)
			sb.WriteString(fmt.Sprintf("        entity.%s(proto.%s);\n", setter, protoGetter))
		}
		sb.WriteString("        return entity;\n")
	}
	sb.WriteString("    }\n\n")

	// Entity to Proto
	sb.WriteString(fmt.Sprintf("    public static %sProto toProto(%s entity) {\n",
		entity.Name, entity.Name))
	sb.WriteString(fmt.Sprintf("        return %sProto.newBuilder()\n", entity.Name))
	for _, field := range entity.Fields {
		getter := "get" + ToPascalCase(field.Name) + "()"
		setter := "set" + ToPascalCase(field.Name)
		sb.WriteString(fmt.Sprintf("            .%s(entity.%s)\n", setter, getter))
	}
	sb.WriteString("            .build();\n")
	sb.WriteString("    }\n")

	sb.WriteString("}\n")

	return sb.String()
}

// Helper methods

func (g *JavaGenerator) getJavaSetter(field *parser.FieldDecl, index int) string {
	getter := "entity.get" + ToPascalCase(field.Name) + "()"
	method := g.getPreparedStatementMethod(field.Type.Name)

	// Handle boolean conversion for SQLite
	if field.Type.Name == "bool" {
		return fmt.Sprintf("stmt.setInt(%d, %s ? 1 : 0);", index, getter)
	}

	return fmt.Sprintf("stmt.%s(%d, %s);", method, index, getter)
}

func (g *JavaGenerator) getPreparedStatementMethod(typeName string) string {
	switch typeName {
	case "string":
		return "setString"
	case "int32":
		return "setInt"
	case "int64", "timestamp":
		return "setLong"
	case "float":
		return "setFloat"
	case "double":
		return "setDouble"
	case "bool":
		return "setBoolean"
	case "bytes":
		return "setBytes"
	default:
		return "setString"
	}
}

func (g *JavaGenerator) getResultSetGetter(field *parser.FieldDecl) string {
	col := ToSnakeCase(field.Name)

	switch field.Type.Name {
	case "string":
		return fmt.Sprintf("rs.getString(\"%s\")", col)
	case "int32":
		return fmt.Sprintf("rs.getInt(\"%s\")", col)
	case "int64", "timestamp":
		return fmt.Sprintf("rs.getLong(\"%s\")", col)
	case "float":
		return fmt.Sprintf("rs.getFloat(\"%s\")", col)
	case "double":
		return fmt.Sprintf("rs.getDouble(\"%s\")", col)
	case "bool":
		return fmt.Sprintf("rs.getInt(\"%s\") == 1", col)
	case "bytes":
		return fmt.Sprintf("rs.getBytes(\"%s\")", col)
	default:
		return fmt.Sprintf("rs.getString(\"%s\")", col)
	}
}

func (g *JavaGenerator) getWrapperType(primitiveType string) string {
	switch primitiveType {
	case "int":
		return "Integer"
	case "long":
		return "Long"
	case "float":
		return "Float"
	case "double":
		return "Double"
	case "boolean":
		return "Boolean"
	default:
		return primitiveType
	}
}
