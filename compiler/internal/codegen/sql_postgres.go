package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// PostgresGenerator generates PostgreSQL DDL from DataProto schemas.
type PostgresGenerator struct {
	// IncludeDropStatements adds DROP TABLE IF EXISTS before CREATE
	IncludeDropStatements bool
	// UseSerial uses SERIAL instead of GENERATED for auto-increment
	UseSerial bool
}

// NewPostgresGenerator creates a new PostgresGenerator.
func NewPostgresGenerator() *PostgresGenerator {
	return &PostgresGenerator{}
}

// Generate generates PostgreSQL DDL from a DataProto file.
func (g *PostgresGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	var sb strings.Builder

	// Header
	sb.WriteString("-- Code generated by dataprotoc. DO NOT EDIT.\n")
	sb.WriteString("-- source: ")
	if file.Package != nil {
		sb.WriteString(file.Package.Name)
	}
	sb.WriteString(".dataproto\n")
	sb.WriteString("-- target: PostgreSQL\n\n")

	// Generate tables for each entity
	for _, entity := range file.Entities {
		// Check if postgres is a supported backend
		backends := entity.Backends()
		if len(backends) > 0 {
			supported := false
			for _, b := range backends {
				if b == "postgres" || b == "postgresql" {
					supported = true
					break
				}
			}
			if !supported {
				continue
			}
		}

		tableDDL, err := g.generateTable(entity)
		if err != nil {
			return nil, err
		}
		sb.WriteString(tableDDL)
		sb.WriteString("\n")

		// Generate indexes
		indexes := g.generateIndexes(entity)
		sb.WriteString(indexes)
		if indexes != "" {
			sb.WriteString("\n")
		}
	}

	// Generate filename
	filename := "schema.sql"
	if file.Package != nil {
		parts := strings.Split(file.Package.Name, ".")
		filename = parts[len(parts)-1] + "_postgres.sql"
	}

	result[filename] = sb.String()
	return result, nil
}

func (g *PostgresGenerator) generateTable(entity *parser.EntityDecl) (string, error) {
	var sb strings.Builder

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	if g.IncludeDropStatements {
		sb.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS %s CASCADE;\n\n", tableName))
	}

	sb.WriteString(fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (\n", tableName))

	var columns []string
	var constraints []string

	for _, field := range entity.Fields {
		colDef := g.generateColumn(field)
		columns = append(columns, "    "+colDef)

		// Unique constraint (separate from column for Postgres)
		if field.IsUnique() && !field.IsPrimaryKey() {
			constraints = append(constraints,
				fmt.Sprintf("    CONSTRAINT uq_%s_%s UNIQUE (%s)",
					tableName, ToSnakeCase(field.Name), ToSnakeCase(field.Name)))
		}

		// Foreign key constraint
		if fk := field.GetAnnotation("fk"); fk != nil && len(fk.Args) > 0 {
			if ref, ok := fk.Args[0].Value.(string); ok {
				parts := strings.Split(ref, ".")
				if len(parts) == 2 {
					refTable := ToSnakeCase(parts[0])
					refColumn := ToSnakeCase(parts[1])

					onDelete := "RESTRICT"
					if od := field.GetAnnotation("ondelete"); od != nil && len(od.Args) > 0 {
						if action, ok := od.Args[0].Value.(string); ok {
							switch strings.ToLower(action) {
							case "cascade":
								onDelete = "CASCADE"
							case "setnull":
								onDelete = "SET NULL"
							case "restrict":
								onDelete = "RESTRICT"
							}
						}
					}

					constraints = append(constraints,
						fmt.Sprintf("    CONSTRAINT fk_%s_%s FOREIGN KEY (%s) REFERENCES %s(%s) ON DELETE %s",
							tableName, ToSnakeCase(field.Name), ToSnakeCase(field.Name),
							refTable, refColumn, onDelete))
				}
			}
		}
	}

	// Combine columns and constraints
	allDefs := append(columns, constraints...)
	sb.WriteString(strings.Join(allDefs, ",\n"))
	sb.WriteString("\n);\n")

	return sb.String(), nil
}

func (g *PostgresGenerator) generateColumn(field *parser.FieldDecl) string {
	colName := ToSnakeCase(field.Name)
	sqlType := g.postgresType(field.Type.Name)

	var parts []string
	parts = append(parts, colName, sqlType)

	// Primary key
	if field.IsPrimaryKey() {
		parts = append(parts, "PRIMARY KEY")
	}

	// NOT NULL
	if !field.Type.Optional && !field.IsPrimaryKey() {
		if field.IsRequired() || field.GetAnnotation("default") == nil {
			parts = append(parts, "NOT NULL")
		}
	}

	// Default value
	if def := field.GetAnnotation("default"); def != nil && len(def.Args) > 0 {
		defaultVal := g.formatDefaultValue(def.Args[0].Value, field.Type.Name)
		parts = append(parts, fmt.Sprintf("DEFAULT %s", defaultVal))
	}

	return strings.Join(parts, " ")
}

func (g *PostgresGenerator) postgresType(typeName string) string {
	switch typeName {
	case "string":
		return "TEXT"
	case "int32":
		return "INTEGER"
	case "int64":
		return "BIGINT"
	case "float":
		return "REAL"
	case "double":
		return "DOUBLE PRECISION"
	case "bool":
		return "BOOLEAN"
	case "bytes":
		return "BYTEA"
	case "timestamp":
		return "BIGINT" // epoch milliseconds
	default:
		return "TEXT"
	}
}

func (g *PostgresGenerator) formatDefaultValue(value interface{}, typeName string) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))
	case bool:
		if v {
			return "TRUE"
		}
		return "FALSE"
	case int64:
		return fmt.Sprintf("%d", v)
	case float64:
		return fmt.Sprintf("%f", v)
	default:
		return "NULL"
	}
}

func (g *PostgresGenerator) generateIndexes(entity *parser.EntityDecl) string {
	var sb strings.Builder

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	for _, field := range entity.Fields {
		if field.IsIndexed() && !field.IsPrimaryKey() {
			colName := ToSnakeCase(field.Name)
			indexName := fmt.Sprintf("idx_%s_%s", tableName, colName)

			sb.WriteString(fmt.Sprintf("CREATE INDEX IF NOT EXISTS %s ON %s (%s);\n",
				indexName, tableName, colName))
		}
	}

	return sb.String()
}

// GenerateMigration generates an additive-only migration.
func (g *PostgresGenerator) GenerateMigration(from, to *parser.EntityDecl) (string, []string, error) {
	var sb strings.Builder
	var blocked []string

	tableName := to.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(to.Name)
	}

	// Build field maps
	fromFields := make(map[string]*parser.FieldDecl)
	if from != nil {
		for _, f := range from.Fields {
			fromFields[f.Name] = f
		}
	}

	toFields := make(map[string]*parser.FieldDecl)
	for _, f := range to.Fields {
		toFields[f.Name] = f
	}

	sb.WriteString(fmt.Sprintf("-- Migration for table: %s\n", tableName))
	sb.WriteString("-- ADDITIVE ONLY: Foundation columns cannot be removed or changed.\n\n")

	// Find added columns (allowed)
	for name, field := range toFields {
		if _, exists := fromFields[name]; !exists {
			// New column - must be optional or have default
			if !field.Type.Optional && field.GetAnnotation("default") == nil {
				blocked = append(blocked,
					fmt.Sprintf("Cannot add required column '%s' without default value", name))
				continue
			}
			colDef := g.generateColumn(field)
			sb.WriteString(fmt.Sprintf("ALTER TABLE %s ADD COLUMN %s;\n", tableName, colDef))
		}
	}

	// Find removed columns (blocked)
	for name := range fromFields {
		if _, exists := toFields[name]; !exists {
			blocked = append(blocked,
				fmt.Sprintf("Cannot remove foundation column '%s'", name))
		}
	}

	// Find changed types (blocked)
	for name, fromField := range fromFields {
		if toField, exists := toFields[name]; exists {
			if fromField.Type.Name != toField.Type.Name {
				blocked = append(blocked,
					fmt.Sprintf("Cannot change type of '%s' from %s to %s",
						name, fromField.Type.Name, toField.Type.Name))
			}
		}
	}

	return sb.String(), blocked, nil
}
