package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// KotlinGenerator generates Kotlin code from DataProto schemas.
// Kotlin is used for Android client development, similar to Swift for iOS.
// Generated code communicates with the Java server via gRPC.
type KotlinGenerator struct {
	PackageName      string // Kotlin package name
	GrpcPackage      string // gRPC generated code package
	GenerateMappers  bool   // Generate proto<->entity mappers
	GenerateClients  bool   // Generate gRPC service clients
	UseCoroutines    bool   // Use Kotlin coroutines (suspend functions)
	UseFlow          bool   // Use Kotlin Flow for streaming
}

// NewKotlinGenerator creates a new KotlinGenerator with defaults.
func NewKotlinGenerator() *KotlinGenerator {
	return &KotlinGenerator{
		GrpcPackage:     "proto",
		GenerateMappers: true,
		GenerateClients: true,
		UseCoroutines:   true,
		UseFlow:         true,
	}
}

// Generate generates Kotlin code from a DataProto file.
func (g *KotlinGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	// Set package name from file
	if file.Package != nil && g.PackageName == "" {
		g.PackageName = file.Package.Name
	}

	// Generate data classes for each entity
	for _, entity := range file.Entities {
		// Data class (DTO)
		dataClass := g.generateDataClass(entity)
		result[entity.Name+".kt"] = dataClass

		// Proto Mapper
		if g.GenerateMappers {
			mapper := g.generateMapper(entity)
			result[entity.Name+"Mapper.kt"] = mapper
		}
	}

	// Generate gRPC service clients
	if g.GenerateClients {
		for _, service := range file.Services {
			client := g.generateServiceClient(service, file)
			result[service.Name+"Client.kt"] = client
		}
	}

	return result, nil
}

func (g *KotlinGenerator) generateDataClass(entity *parser.EntityDecl) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")

	if g.PackageName != "" {
		sb.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))
	}

	// Imports
	sb.WriteString("import kotlinx.serialization.Serializable\n")
	sb.WriteString("import kotlinx.serialization.SerialName\n\n")

	// Data class
	sb.WriteString("@Serializable\n")
	sb.WriteString(fmt.Sprintf("data class %s(\n", entity.Name))

	// Properties
	for i, field := range entity.Fields {
		if i > 0 {
			sb.WriteString(",\n")
		}

		kotlinType := g.kotlinType(field.Type.Name, field.Type.Optional)
		propertyName := ToCamelCase(field.Name)
		snakeName := ToSnakeCase(field.Name)

		// Add doc comment for special fields
		if field.IsPrimaryKey() {
			sb.WriteString("    /** Primary key */\n")
		}

		// SerialName for JSON mapping
		if propertyName != snakeName {
			sb.WriteString(fmt.Sprintf("    @SerialName(\"%s\")\n", snakeName))
		}

		// Property definition
		defaultValue := ""
		if field.Type.Optional {
			defaultValue = " = null"
		} else if def := field.GetAnnotation("default"); def != nil && len(def.Args) > 0 {
			defaultValue = " = " + g.kotlinDefaultValue(def.Args[0].Value, field.Type.Name)
		}

		sb.WriteString(fmt.Sprintf("    val %s: %s%s", propertyName, kotlinType, defaultValue))
	}

	sb.WriteString("\n)")

	// Add companion object with table name
	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}
	sb.WriteString(" {\n")
	sb.WriteString("    companion object {\n")
	sb.WriteString(fmt.Sprintf("        const val TABLE_NAME = \"%s\"\n", tableName))
	sb.WriteString("    }\n")
	sb.WriteString("}\n")

	return sb.String()
}

func (g *KotlinGenerator) generateMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")

	if g.PackageName != "" {
		sb.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))
	}

	// Import proto classes
	sb.WriteString(fmt.Sprintf("import %s.%sOuterClass.%s as %sProto\n\n",
		g.GrpcPackage, entity.Name, entity.Name, entity.Name))

	// Object for mapper functions
	sb.WriteString(fmt.Sprintf("object %sMapper {\n\n", entity.Name))

	// From proto -> entity
	sb.WriteString(fmt.Sprintf("    /**\n     * Convert proto message to domain entity.\n     */\n"))
	sb.WriteString(fmt.Sprintf("    fun fromProto(proto: %sProto): %s {\n",
		entity.Name, entity.Name))
	sb.WriteString(fmt.Sprintf("        return %s(\n", entity.Name))

	for i, field := range entity.Fields {
		if i > 0 {
			sb.WriteString(",\n")
		}
		propertyName := ToCamelCase(field.Name)
		protoGetter := g.protoGetterForKotlin(field)
		sb.WriteString(fmt.Sprintf("            %s = %s", propertyName, protoGetter))
	}

	sb.WriteString("\n        )\n")
	sb.WriteString("    }\n\n")

	// To proto -> from entity
	sb.WriteString(fmt.Sprintf("    /**\n     * Convert domain entity to proto message.\n     */\n"))
	sb.WriteString(fmt.Sprintf("    fun toProto(entity: %s): %sProto {\n",
		entity.Name, entity.Name))
	sb.WriteString(fmt.Sprintf("        return %sProto.newBuilder().apply {\n", entity.Name))

	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		setter := g.protoSetterForKotlin(field)
		sb.WriteString(fmt.Sprintf("            %s(entity.%s)\n", setter, propertyName))
	}

	sb.WriteString("        }.build()\n")
	sb.WriteString("    }\n\n")

	// List conversions
	sb.WriteString(fmt.Sprintf("    fun fromProtoList(protos: List<%sProto>): List<%s> =\n",
		entity.Name, entity.Name))
	sb.WriteString("        protos.map { fromProto(it) }\n\n")

	sb.WriteString(fmt.Sprintf("    fun toProtoList(entities: List<%s>): List<%sProto> =\n",
		entity.Name, entity.Name))
	sb.WriteString("        entities.map { toProto(it) }\n")

	sb.WriteString("}\n")

	return sb.String()
}

func (g *KotlinGenerator) generateServiceClient(service *parser.ServiceDecl, file *parser.File) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")

	if g.PackageName != "" {
		sb.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))
	}

	// Imports
	sb.WriteString("import io.grpc.ManagedChannel\n")
	sb.WriteString("import io.grpc.ManagedChannelBuilder\n")
	if g.UseCoroutines {
		sb.WriteString("import kotlinx.coroutines.Dispatchers\n")
		sb.WriteString("import kotlinx.coroutines.withContext\n")
	}
	if g.UseFlow {
		sb.WriteString("import kotlinx.coroutines.flow.Flow\n")
		sb.WriteString("import kotlinx.coroutines.flow.flow\n")
		sb.WriteString("import kotlinx.coroutines.flow.map\n")
	}
	sb.WriteString(fmt.Sprintf("import %s.%sGrpc\n", g.GrpcPackage, service.Name))
	sb.WriteString(fmt.Sprintf("import %s.%sGrpcKt\n", g.GrpcPackage, service.Name))
	sb.WriteString("\n")

	// Client class
	sb.WriteString(fmt.Sprintf("/**\n * gRPC client for %s.\n", service.Name))
	sb.WriteString(" * Communicates with the Aurora Java server.\n */\n")
	sb.WriteString(fmt.Sprintf("class %sClient(\n", service.Name))
	sb.WriteString("    private val host: String = \"localhost\",\n")
	sb.WriteString("    private val port: Int = 50051\n")
	sb.WriteString(") {\n\n")

	// Channel and stub
	sb.WriteString("    private val channel: ManagedChannel by lazy {\n")
	sb.WriteString("        ManagedChannelBuilder.forAddress(host, port)\n")
	sb.WriteString("            .usePlaintext()\n")
	sb.WriteString("            .build()\n")
	sb.WriteString("    }\n\n")

	sb.WriteString(fmt.Sprintf("    private val stub: %sGrpcKt.%sCoroutineStub by lazy {\n",
		service.Name, service.Name))
	sb.WriteString(fmt.Sprintf("        %sGrpcKt.%sCoroutineStub(channel)\n",
		service.Name, service.Name))
	sb.WriteString("    }\n\n")

	// Generate methods for each RPC
	for _, method := range service.Methods {
		sb.WriteString(g.generateServiceMethod(method, service, file))
	}

	// Shutdown method
	sb.WriteString("    /**\n     * Shutdown the gRPC channel.\n     */\n")
	sb.WriteString("    fun shutdown() {\n")
	sb.WriteString("        channel.shutdown()\n")
	sb.WriteString("    }\n")

	sb.WriteString("}\n")

	return sb.String()
}

func (g *KotlinGenerator) generateServiceMethod(method *parser.RpcDecl, service *parser.ServiceDecl, file *parser.File) string {
	var sb strings.Builder

	methodName := ToCamelCase(method.Name)
	requestType := method.RequestType.Name
	responseType := method.ResponseType.Name

	// Find if response type is an entity (for mapping)
	var responseEntity *parser.EntityDecl
	for _, e := range file.Entities {
		if e.Name == responseType {
			responseEntity = e
			break
		}
	}

	// Client streaming (push)
	if method.RequestType.Stream && !method.ResponseType.Stream {
		sb.WriteString(fmt.Sprintf("    /**\n     * %s - client streaming RPC.\n     */\n", method.Name))
		sb.WriteString(fmt.Sprintf("    suspend fun %s(items: List<%s>): %s {\n",
			methodName, requestType, responseType))
		sb.WriteString("        return withContext(Dispatchers.IO) {\n")
		sb.WriteString(fmt.Sprintf("            val protos = %sMapper.toProtoList(items)\n", requestType))
		sb.WriteString(fmt.Sprintf("            stub.%s(protos.asFlow())\n", methodName))
		sb.WriteString("        }\n")
		sb.WriteString("    }\n\n")
		return sb.String()
	}

	// Server streaming (get)
	if !method.RequestType.Stream && method.ResponseType.Stream {
		sb.WriteString(fmt.Sprintf("    /**\n     * %s - server streaming RPC.\n     */\n", method.Name))

		if responseEntity != nil {
			// Return Flow of domain entities
			sb.WriteString(fmt.Sprintf("    fun %s(request: %s): Flow<%s> {\n",
				methodName, requestType, responseType))
			sb.WriteString(fmt.Sprintf("        return stub.%s(request).map { %sMapper.fromProto(it) }\n",
				methodName, responseType))
		} else {
			// Return Flow of proto messages
			sb.WriteString(fmt.Sprintf("    fun %s(request: %s): Flow<%sProto> {\n",
				methodName, requestType, responseType))
			sb.WriteString(fmt.Sprintf("        return stub.%s(request)\n", methodName))
		}
		sb.WriteString("    }\n\n")
		return sb.String()
	}

	// Bidirectional streaming
	if method.RequestType.Stream && method.ResponseType.Stream {
		sb.WriteString(fmt.Sprintf("    /**\n     * %s - bidirectional streaming RPC.\n     */\n", method.Name))
		sb.WriteString(fmt.Sprintf("    fun %s(requests: Flow<%s>): Flow<%s> {\n",
			methodName, requestType, responseType))
		if responseEntity != nil {
			sb.WriteString(fmt.Sprintf("        return stub.%s(requests.map { %sMapper.toProto(it) })\n",
				methodName, requestType))
			sb.WriteString(fmt.Sprintf("            .map { %sMapper.fromProto(it) }\n", responseType))
		} else {
			sb.WriteString(fmt.Sprintf("        return stub.%s(requests)\n", methodName))
		}
		sb.WriteString("    }\n\n")
		return sb.String()
	}

	// Unary RPC
	sb.WriteString(fmt.Sprintf("    /**\n     * %s - unary RPC.\n     */\n", method.Name))
	sb.WriteString(fmt.Sprintf("    suspend fun %s(request: %s): %s {\n",
		methodName, requestType, responseType))
	sb.WriteString("        return withContext(Dispatchers.IO) {\n")
	sb.WriteString(fmt.Sprintf("            stub.%s(request)\n", methodName))
	sb.WriteString("        }\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

// Helper methods

func (g *KotlinGenerator) kotlinType(typeName string, optional bool) string {
	baseType := g.kotlinBaseType(typeName)
	if optional {
		return baseType + "?"
	}
	return baseType
}

func (g *KotlinGenerator) kotlinBaseType(typeName string) string {
	switch typeName {
	case "string":
		return "String"
	case "int32":
		return "Int"
	case "int64", "timestamp":
		return "Long"
	case "float":
		return "Float"
	case "double":
		return "Double"
	case "bool":
		return "Boolean"
	case "bytes":
		return "ByteArray"
	default:
		return typeName
	}
}

func (g *KotlinGenerator) kotlinDefaultValue(value interface{}, typeName string) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("\"%s\"", v)
	case bool:
		return fmt.Sprintf("%t", v)
	case int64:
		if typeName == "int64" || typeName == "timestamp" {
			return fmt.Sprintf("%dL", v)
		}
		return fmt.Sprintf("%d", v)
	case float64:
		if typeName == "float" {
			return fmt.Sprintf("%ff", v)
		}
		return fmt.Sprintf("%f", v)
	default:
		return "null"
	}
}

func (g *KotlinGenerator) protoGetterForKotlin(field *parser.FieldDecl) string {
	propertyName := ToCamelCase(field.Name)

	switch field.Type.Name {
	case "bytes":
		if field.Type.Optional {
			return fmt.Sprintf("if (proto.has%s()) proto.%s.toByteArray() else null",
				ToPascalCase(field.Name), propertyName)
		}
		return fmt.Sprintf("proto.%s.toByteArray()", propertyName)
	default:
		if field.Type.Optional {
			return fmt.Sprintf("if (proto.has%s()) proto.%s else null",
				ToPascalCase(field.Name), propertyName)
		}
		return fmt.Sprintf("proto.%s", propertyName)
	}
}

func (g *KotlinGenerator) protoSetterForKotlin(field *parser.FieldDecl) string {
	switch field.Type.Name {
	case "bytes":
		if field.Type.Optional {
			return fmt.Sprintf("entity.%s?.let { set%s(com.google.protobuf.ByteString.copyFrom(it)) }",
				ToCamelCase(field.Name), ToPascalCase(field.Name))
		}
		return fmt.Sprintf("set%s(com.google.protobuf.ByteString.copyFrom(entity.%s))",
			ToPascalCase(field.Name), ToCamelCase(field.Name))
	default:
		if field.Type.Optional {
			return fmt.Sprintf("entity.%s?.let { set%s(it) }",
				ToCamelCase(field.Name), ToPascalCase(field.Name))
		}
		return fmt.Sprintf("set%s", ToPascalCase(field.Name))
	}
}
