package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// PythonGenerator generates Python code from DataProto schemas.
type PythonGenerator struct {
	PackageName        string
	GenerateDataclass  bool // Use dataclasses
	GenerateRepository bool
	UseCertification   bool
}

// NewPythonGenerator creates a new PythonGenerator with defaults.
func NewPythonGenerator() *PythonGenerator {
	return &PythonGenerator{
		GenerateDataclass:  true,
		GenerateRepository: true,
		UseCertification:   true,
	}
}

// Generate generates Python code from a DataProto file.
func (g *PythonGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	// Generate __init__.py
	result["__init__.py"] = g.generateInit(file)

	// Generate models
	modelsCode := g.generateModels(file)
	result["models.py"] = modelsCode

	// Generate repositories
	if g.GenerateRepository {
		repoCode := g.generateRepositories(file)
		result["repositories.py"] = repoCode
	}

	// Generate mappers
	mappersCode := g.generateMappers(file)
	result["mappers.py"] = mappersCode

	return result, nil
}

func (g *PythonGenerator) generateInit(file *parser.File) string {
	var sb strings.Builder

	sb.WriteString("# Code generated by dataprotoc. DO NOT EDIT.\n\n")

	// Export models
	sb.WriteString("from .models import (\n")
	for _, entity := range file.Entities {
		sb.WriteString(fmt.Sprintf("    %s,\n", entity.Name))
	}
	for _, enum := range file.Enums {
		sb.WriteString(fmt.Sprintf("    %s,\n", enum.Name))
	}
	sb.WriteString(")\n\n")

	// Export repositories
	if g.GenerateRepository {
		sb.WriteString("from .repositories import (\n")
		for _, entity := range file.Entities {
			sb.WriteString(fmt.Sprintf("    %sRepository,\n", entity.Name))
		}
		sb.WriteString(")\n\n")
	}

	sb.WriteString("from .mappers import (\n")
	for _, entity := range file.Entities {
		sb.WriteString(fmt.Sprintf("    %sMapper,\n", entity.Name))
	}
	sb.WriteString(")\n")

	return sb.String()
}

func (g *PythonGenerator) generateModels(file *parser.File) string {
	var sb strings.Builder

	sb.WriteString("# Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("from __future__ import annotations\n")
	sb.WriteString("from dataclasses import dataclass, field\n")
	sb.WriteString("from enum import IntEnum\n")
	sb.WriteString("from typing import Optional, List\n\n")

	// Generate enums
	for _, enum := range file.Enums {
		sb.WriteString(g.generateEnum(enum))
		sb.WriteString("\n\n")
	}

	// Generate entity dataclasses
	for _, entity := range file.Entities {
		sb.WriteString(g.generateDataclass(entity))
		sb.WriteString("\n\n")
	}

	return sb.String()
}

func (g *PythonGenerator) generateEnum(enum *parser.EnumDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("class %s(IntEnum):\n", enum.Name))
	sb.WriteString(fmt.Sprintf("    \"\"\"%s enum.\"\"\"\n", enum.Name))

	for _, val := range enum.Values {
		sb.WriteString(fmt.Sprintf("    %s = %d\n", val.Name, val.Number))
	}

	return sb.String()
}

func (g *PythonGenerator) generateDataclass(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString("@dataclass\n")
	sb.WriteString(fmt.Sprintf("class %s:\n", entity.Name))

	// Docstring
	tableName := entity.TableName()
	if tableName != "" {
		sb.WriteString(fmt.Sprintf("    \"\"\"Entity mapped to table '%s'.\"\"\"\n\n", tableName))
	} else {
		sb.WriteString(fmt.Sprintf("    \"\"\"%s entity.\"\"\"\n\n", entity.Name))
	}

	// Fields - required fields first, then optional with defaults
	var requiredFields []*parser.FieldDecl
	var optionalFields []*parser.FieldDecl

	for _, f := range entity.Fields {
		if f.Type.Optional || f.GetAnnotation("default") != nil {
			optionalFields = append(optionalFields, f)
		} else {
			requiredFields = append(requiredFields, f)
		}
	}

	// Required fields
	for _, f := range requiredFields {
		pythonType := g.pythonType(f.Type)
		fieldName := ToSnakeCase(f.Name)
		sb.WriteString(fmt.Sprintf("    %s: %s\n", fieldName, pythonType))
	}

	// Optional fields with defaults
	for _, f := range optionalFields {
		pythonType := g.pythonType(f.Type)
		fieldName := ToSnakeCase(f.Name)

		defaultVal := "None"
		if def := f.GetAnnotation("default"); def != nil && len(def.Args) > 0 {
			defaultVal = g.pythonDefaultValue(def.Args[0].Value, f.Type.Name)
		}

		sb.WriteString(fmt.Sprintf("    %s: %s = %s\n", fieldName, pythonType, defaultVal))
	}

	return sb.String()
}

func (g *PythonGenerator) generateRepositories(file *parser.File) string {
	var sb strings.Builder

	sb.WriteString("# Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("from __future__ import annotations\n")
	sb.WriteString("import sqlite3\n")
	sb.WriteString("from typing import Optional, List\n")
	sb.WriteString("from contextlib import contextmanager\n\n")
	sb.WriteString("from .models import *\n\n")

	// Base repository
	sb.WriteString("class BaseRepository:\n")
	sb.WriteString("    \"\"\"Base repository with database connection.\"\"\"\n\n")
	sb.WriteString("    def __init__(self, db_path: str):\n")
	sb.WriteString("        self.db_path = db_path\n\n")
	sb.WriteString("    @contextmanager\n")
	sb.WriteString("    def _get_connection(self):\n")
	sb.WriteString("        conn = sqlite3.connect(self.db_path)\n")
	sb.WriteString("        conn.row_factory = sqlite3.Row\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            yield conn\n")
	sb.WriteString("        finally:\n")
	sb.WriteString("            conn.close()\n\n\n")

	// Generate repository for each entity
	for _, entity := range file.Entities {
		sb.WriteString(g.generateRepository(entity))
		sb.WriteString("\n\n")
	}

	return sb.String()
}

func (g *PythonGenerator) generateRepository(entity *parser.EntityDecl) string {
	var sb strings.Builder

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	sb.WriteString(fmt.Sprintf("class %sRepository(BaseRepository):\n", entity.Name))
	sb.WriteString(fmt.Sprintf("    \"\"\"Repository for %s entities.\"\"\"\n\n", entity.Name))

	// Table name constant
	sb.WriteString(fmt.Sprintf("    TABLE = \"%s\"\n\n", tableName))

	// Upsert
	sb.WriteString(g.generatePythonUpsert(entity, tableName))

	// Find by ID
	sb.WriteString(g.generatePythonFindById(entity, tableName))

	// Find all
	sb.WriteString(g.generatePythonFindAll(entity, tableName))

	// Delete
	sb.WriteString(g.generatePythonDelete(entity, tableName))

	// Query methods
	for _, query := range entity.Queries {
		sb.WriteString(g.generatePythonQueryMethod(entity, query, tableName))
	}

	// Row mapper
	sb.WriteString(g.generatePythonRowMapper(entity))

	return sb.String()
}

func (g *PythonGenerator) generatePythonUpsert(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	var columns []string
	var placeholders []string
	for _, field := range entity.Fields {
		columns = append(columns, ToSnakeCase(field.Name))
		placeholders = append(placeholders, "?")
	}

	sb.WriteString(fmt.Sprintf("    def upsert(self, entity: %s) -> None:\n", entity.Name))
	sb.WriteString("        \"\"\"Insert or update an entity.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        sql = \"INSERT OR REPLACE INTO %s (%s) VALUES (%s)\"\n",
		tableName, strings.Join(columns, ", "), strings.Join(placeholders, ", ")))
	sb.WriteString("        with self._get_connection() as conn:\n")
	sb.WriteString("            conn.execute(sql, (\n")

	for i, field := range entity.Fields {
		fieldName := ToSnakeCase(field.Name)
		if i < len(entity.Fields)-1 {
			sb.WriteString(fmt.Sprintf("                entity.%s,\n", fieldName))
		} else {
			sb.WriteString(fmt.Sprintf("                entity.%s,\n", fieldName))
		}
	}

	sb.WriteString("            ))\n")
	sb.WriteString("            conn.commit()\n\n")

	return sb.String()
}

func (g *PythonGenerator) generatePythonFindById(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}

	if pkField == nil {
		return ""
	}

	pkName := ToSnakeCase(pkField.Name)
	pkType := g.pythonBaseType(pkField.Type.Name)

	sb.WriteString(fmt.Sprintf("    def find_by_id(self, %s: %s) -> Optional[%s]:\n",
		pkName, pkType, entity.Name))
	sb.WriteString("        \"\"\"Find an entity by its primary key.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        sql = \"SELECT * FROM %s WHERE %s = ?\"\n",
		tableName, pkName))
	sb.WriteString("        with self._get_connection() as conn:\n")
	sb.WriteString(fmt.Sprintf("            row = conn.execute(sql, (%s,)).fetchone()\n", pkName))
	sb.WriteString("            return self._map_row(row) if row else None\n\n")

	return sb.String()
}

func (g *PythonGenerator) generatePythonFindAll(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("    def find_all(self) -> List[%s]:\n", entity.Name))
	sb.WriteString("        \"\"\"Find all entities.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        sql = \"SELECT * FROM %s\"\n", tableName))
	sb.WriteString("        with self._get_connection() as conn:\n")
	sb.WriteString("            rows = conn.execute(sql).fetchall()\n")
	sb.WriteString("            return [self._map_row(row) for row in rows]\n\n")

	return sb.String()
}

func (g *PythonGenerator) generatePythonDelete(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}

	if pkField == nil {
		return ""
	}

	pkName := ToSnakeCase(pkField.Name)
	pkType := g.pythonBaseType(pkField.Type.Name)

	sb.WriteString(fmt.Sprintf("    def delete(self, %s: %s) -> bool:\n", pkName, pkType))
	sb.WriteString("        \"\"\"Delete an entity by its primary key.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        sql = \"DELETE FROM %s WHERE %s = ?\"\n",
		tableName, pkName))
	sb.WriteString("        with self._get_connection() as conn:\n")
	sb.WriteString(fmt.Sprintf("            cursor = conn.execute(sql, (%s,))\n", pkName))
	sb.WriteString("            conn.commit()\n")
	sb.WriteString("            return cursor.rowcount > 0\n\n")

	return sb.String()
}

func (g *PythonGenerator) generatePythonQueryMethod(entity *parser.EntityDecl, query *parser.QueryDecl, tableName string) string {
	var sb strings.Builder

	// Method name and signature
	methodName := ToSnakeCase(query.Name)
	sb.WriteString(fmt.Sprintf("    def %s(self", methodName))

	for _, p := range query.Params {
		pythonType := g.pythonType(p.Type)
		paramName := ToSnakeCase(p.Name)
		if p.Default != nil {
			sb.WriteString(fmt.Sprintf(", %s: %s = %s",
				paramName, pythonType, g.pythonDefaultValue(p.Default, p.Type.Name)))
		} else {
			sb.WriteString(fmt.Sprintf(", %s: %s", paramName, pythonType))
		}
	}

	sb.WriteString(fmt.Sprintf(") -> List[%s]:\n", entity.Name))
	sb.WriteString(fmt.Sprintf("        \"\"\"Query: %s\"\"\"\n", query.Name))

	// Build set of known parameter names
	knownParams := make(map[string]bool)
	for _, p := range query.Params {
		knownParams[p.Name] = true
	}

	// Build SQL
	var sqlParts []string
	sqlParts = append(sqlParts, fmt.Sprintf("SELECT * FROM %s", tableName))

	if query.Where != nil {
		whereSQL, _ := ExprToSQLWithKnownParams(query.Where, knownParams)
		sqlParts = append(sqlParts, "WHERE "+whereSQL)
	}

	if len(query.OrderBy) > 0 {
		var orderParts []string
		for _, o := range query.OrderBy {
			dir := "ASC"
			if o.Descending {
				dir = "DESC"
			}
			orderParts = append(orderParts, fmt.Sprintf("%s %s", ToSnakeCase(o.Field), dir))
		}
		sqlParts = append(sqlParts, "ORDER BY "+strings.Join(orderParts, ", "))
	}

	if query.Limit != nil {
		if _, ok := query.Limit.(*parser.IdentExpr); ok {
			sqlParts = append(sqlParts, "LIMIT ?")
		} else if lit, ok := query.Limit.(*parser.LiteralExpr); ok {
			if val, ok := lit.Value.(int64); ok {
				sqlParts = append(sqlParts, fmt.Sprintf("LIMIT %d", val))
			}
		}
	}

	sb.WriteString(fmt.Sprintf("        sql = \"%s\"\n", strings.Join(sqlParts, " ")))

	// Build params tuple
	sb.WriteString("        params = (")
	var paramNames []string
	for _, p := range query.Params {
		paramNames = append(paramNames, ToSnakeCase(p.Name))
	}
	if query.Limit != nil {
		if l, ok := query.Limit.(*parser.IdentExpr); ok {
			paramNames = append(paramNames, ToSnakeCase(l.Name))
		}
	}
	sb.WriteString(strings.Join(paramNames, ", "))
	if len(paramNames) == 1 {
		sb.WriteString(",") // Single-element tuple needs trailing comma
	}
	sb.WriteString(")\n")

	sb.WriteString("        with self._get_connection() as conn:\n")
	sb.WriteString("            rows = conn.execute(sql, params).fetchall()\n")
	sb.WriteString("            return [self._map_row(row) for row in rows]\n\n")

	return sb.String()
}

func (g *PythonGenerator) generatePythonRowMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("    def _map_row(self, row: sqlite3.Row) -> %s:\n", entity.Name))
	sb.WriteString("        \"\"\"Map a database row to an entity.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        return %s(\n", entity.Name))

	for _, field := range entity.Fields {
		fieldName := ToSnakeCase(field.Name)
		getter := g.pythonRowGetter(field)
		sb.WriteString(fmt.Sprintf("            %s=%s,\n", fieldName, getter))
	}

	sb.WriteString("        )\n")

	return sb.String()
}

func (g *PythonGenerator) generateMappers(file *parser.File) string {
	var sb strings.Builder

	sb.WriteString("# Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("from __future__ import annotations\n")
	sb.WriteString("from typing import TYPE_CHECKING\n\n")
	sb.WriteString("from .models import *\n\n")
	sb.WriteString("if TYPE_CHECKING:\n")
	sb.WriteString("    # Import proto types for type checking\n")
	sb.WriteString("    pass\n\n\n")

	for _, entity := range file.Entities {
		sb.WriteString(g.generateMapper(entity))
		sb.WriteString("\n\n")
	}

	return sb.String()
}

func (g *PythonGenerator) generateMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("class %sMapper:\n", entity.Name))
	sb.WriteString(fmt.Sprintf("    \"\"\"Mapper for %s <-> Proto conversions.\"\"\"\n\n", entity.Name))

	// From proto
	sb.WriteString("    @staticmethod\n")
	sb.WriteString(fmt.Sprintf("    def from_proto(proto) -> %s:\n", entity.Name))
	sb.WriteString("        \"\"\"Convert from protobuf message.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        return %s(\n", entity.Name))

	for _, field := range entity.Fields {
		fieldName := ToSnakeCase(field.Name)
		protoName := ToCamelCase(field.Name)

		if field.Type.Optional {
			sb.WriteString(fmt.Sprintf("            %s=proto.%s if proto.HasField('%s') else None,\n",
				fieldName, protoName, protoName))
		} else {
			sb.WriteString(fmt.Sprintf("            %s=proto.%s,\n", fieldName, protoName))
		}
	}

	sb.WriteString("        )\n\n")

	// To proto
	sb.WriteString("    @staticmethod\n")
	sb.WriteString(fmt.Sprintf("    def to_proto(entity: %s):\n", entity.Name))
	sb.WriteString("        \"\"\"Convert to protobuf message.\"\"\"\n")
	sb.WriteString(fmt.Sprintf("        # Import here to avoid circular imports\n"))
	sb.WriteString(fmt.Sprintf("        from . import %s_pb2\n\n", ToSnakeCase(entity.Name)))
	sb.WriteString(fmt.Sprintf("        proto = %s_pb2.%s()\n", ToSnakeCase(entity.Name), entity.Name))

	for _, field := range entity.Fields {
		fieldName := ToSnakeCase(field.Name)
		protoName := ToCamelCase(field.Name)

		if field.Type.Optional {
			sb.WriteString(fmt.Sprintf("        if entity.%s is not None:\n", fieldName))
			sb.WriteString(fmt.Sprintf("            proto.%s = entity.%s\n", protoName, fieldName))
		} else {
			sb.WriteString(fmt.Sprintf("        proto.%s = entity.%s\n", protoName, fieldName))
		}
	}

	sb.WriteString("        return proto\n")

	return sb.String()
}

// Helper methods

func (g *PythonGenerator) pythonType(typeRef *parser.TypeRef) string {
	baseType := g.pythonBaseType(typeRef.Name)
	if typeRef.Optional {
		return fmt.Sprintf("Optional[%s]", baseType)
	}
	return baseType
}

func (g *PythonGenerator) pythonBaseType(typeName string) string {
	switch typeName {
	case "string":
		return "str"
	case "int32", "int64", "timestamp":
		return "int"
	case "float", "double":
		return "float"
	case "bool":
		return "bool"
	case "bytes":
		return "bytes"
	default:
		return typeName
	}
}

func (g *PythonGenerator) pythonDefaultValue(value interface{}, typeName string) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("\"%s\"", v)
	case bool:
		if v {
			return "True"
		}
		return "False"
	case int64:
		return fmt.Sprintf("%d", v)
	case float64:
		return fmt.Sprintf("%f", v)
	default:
		return "None"
	}
}

func (g *PythonGenerator) pythonRowGetter(field *parser.FieldDecl) string {
	fieldName := ToSnakeCase(field.Name)

	switch field.Type.Name {
	case "bool":
		if field.Type.Optional {
			return fmt.Sprintf("bool(row['%s']) if row['%s'] is not None else None",
				fieldName, fieldName)
		}
		return fmt.Sprintf("bool(row['%s'])", fieldName)
	default:
		return fmt.Sprintf("row['%s']", fieldName)
	}
}
