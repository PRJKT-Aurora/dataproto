package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// QtGenerator generates Qt/C++ code from DataProto schemas.
type QtGenerator struct {
	Namespace          string // C++ namespace
	GenerateQObject    bool   // Generate Q_OBJECT classes with signals/slots
	GenerateRepository bool   // Generate repository classes
	GenerateQML        bool   // Generate QML-compatible types
}

// NewQtGenerator creates a new QtGenerator with defaults.
func NewQtGenerator() *QtGenerator {
	return &QtGenerator{
		Namespace:          "dataproto",
		GenerateQObject:    true,
		GenerateRepository: true,
		GenerateQML:        true,
	}
}

// Generate generates Qt/C++ code from a DataProto file.
func (g *QtGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	// Set namespace from package
	if file.Package != nil && g.Namespace == "dataproto" {
		g.Namespace = strings.ReplaceAll(file.Package.Name, ".", "::")
	}

	// Generate header and source for each entity
	for _, entity := range file.Entities {
		headerCode := g.generateHeader(entity)
		result[ToSnakeCase(entity.Name)+".h"] = headerCode

		sourceCode := g.generateSource(entity)
		result[ToSnakeCase(entity.Name)+".cpp"] = sourceCode

		if g.GenerateRepository {
			repoHeader := g.generateRepositoryHeader(entity)
			result[ToSnakeCase(entity.Name)+"_repository.h"] = repoHeader

			repoSource := g.generateRepositorySource(entity)
			result[ToSnakeCase(entity.Name)+"_repository.cpp"] = repoSource
		}
	}

	// Generate enums
	for _, enum := range file.Enums {
		enumHeader := g.generateEnumHeader(enum)
		result[ToSnakeCase(enum.Name)+".h"] = enumHeader
	}

	// Generate CMakeLists.txt
	result["CMakeLists.txt"] = g.generateCMakeLists(file)

	return result, nil
}

func (g *QtGenerator) generateHeader(entity *parser.EntityDecl) string {
	var sb strings.Builder
	className := entity.Name
	guardName := strings.ToUpper(ToSnakeCase(entity.Name)) + "_H"

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("#ifndef %s\n", guardName))
	sb.WriteString(fmt.Sprintf("#define %s\n\n", guardName))

	// Includes
	sb.WriteString("#include <QObject>\n")
	sb.WriteString("#include <QString>\n")
	sb.WriteString("#include <QDateTime>\n")
	if g.GenerateQML {
		sb.WriteString("#include <QtQml/qqmlregistration.h>\n")
	}
	sb.WriteString("\n")

	// Namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("namespace %s {\n\n", g.Namespace))
	}

	// Class declaration
	if g.GenerateQObject {
		sb.WriteString(fmt.Sprintf("class %s : public QObject\n", className))
		sb.WriteString("{\n")
		sb.WriteString("    Q_OBJECT\n")
		if g.GenerateQML {
			sb.WriteString("    QML_ELEMENT\n")
		}
		sb.WriteString("\n")

		// Q_PROPERTY declarations
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			propName := ToCamelCase(field.Name)
			sb.WriteString(fmt.Sprintf("    Q_PROPERTY(%s %s READ %s WRITE set%s NOTIFY %sChanged)\n",
				qtType, propName, propName, ToPascalCase(field.Name), propName))
		}
		sb.WriteString("\n")
	} else {
		sb.WriteString(fmt.Sprintf("struct %s\n", className))
		sb.WriteString("{\n")
	}

	sb.WriteString("public:\n")

	if g.GenerateQObject {
		// Constructor
		sb.WriteString(fmt.Sprintf("    explicit %s(QObject *parent = nullptr);\n", className))
		sb.WriteString(fmt.Sprintf("    ~%s() override = default;\n\n", className))

		// Copy constructor and factory
		sb.WriteString(fmt.Sprintf("    static %s* create(", className))
		var params []string
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			paramName := ToCamelCase(field.Name)
			params = append(params, fmt.Sprintf("%s %s", qtType, paramName))
		}
		sb.WriteString(strings.Join(params, ", "))
		sb.WriteString(", QObject *parent = nullptr);\n\n")

		// Getters and setters
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			propName := ToCamelCase(field.Name)
			sb.WriteString(fmt.Sprintf("    %s %s() const;\n", qtType, propName))
			sb.WriteString(fmt.Sprintf("    void set%s(%s value);\n\n", ToPascalCase(field.Name), qtType))
		}

		// Signals
		sb.WriteString("signals:\n")
		for _, field := range entity.Fields {
			propName := ToCamelCase(field.Name)
			sb.WriteString(fmt.Sprintf("    void %sChanged();\n", propName))
		}
		sb.WriteString("\n")

		// Private members
		sb.WriteString("private:\n")
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			memberName := "m_" + ToCamelCase(field.Name)
			sb.WriteString(fmt.Sprintf("    %s %s;\n", qtType, memberName))
		}
	} else {
		// Simple struct members
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			memberName := ToCamelCase(field.Name)
			sb.WriteString(fmt.Sprintf("    %s %s;\n", qtType, memberName))
		}
	}

	sb.WriteString("};\n\n")

	// Close namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("} // namespace %s\n\n", g.Namespace))
	}

	sb.WriteString(fmt.Sprintf("#endif // %s\n", guardName))

	return sb.String()
}

func (g *QtGenerator) generateSource(entity *parser.EntityDecl) string {
	var sb strings.Builder
	className := entity.Name
	headerName := ToSnakeCase(entity.Name) + ".h"

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("#include \"%s\"\n\n", headerName))

	// Namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("namespace %s {\n\n", g.Namespace))
	}

	if g.GenerateQObject {
		// Constructor
		sb.WriteString(fmt.Sprintf("%s::%s(QObject *parent)\n", className, className))
		sb.WriteString("    : QObject(parent)\n")

		// Initialize members
		for i, field := range entity.Fields {
			memberName := "m_" + ToCamelCase(field.Name)
			defaultVal := g.qtDefaultValue(field)
			if i == 0 {
				sb.WriteString(fmt.Sprintf("    , %s(%s)\n", memberName, defaultVal))
			} else {
				sb.WriteString(fmt.Sprintf("    , %s(%s)\n", memberName, defaultVal))
			}
		}
		sb.WriteString("{\n}\n\n")

		// Factory method
		sb.WriteString(fmt.Sprintf("%s* %s::create(", className, className))
		var params []string
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			paramName := ToCamelCase(field.Name)
			params = append(params, fmt.Sprintf("%s %s", qtType, paramName))
		}
		sb.WriteString(strings.Join(params, ", "))
		sb.WriteString(", QObject *parent)\n{\n")
		sb.WriteString(fmt.Sprintf("    auto *obj = new %s(parent);\n", className))
		for _, field := range entity.Fields {
			propName := ToCamelCase(field.Name)
			sb.WriteString(fmt.Sprintf("    obj->set%s(%s);\n", ToPascalCase(field.Name), propName))
		}
		sb.WriteString("    return obj;\n}\n\n")

		// Getters and setters
		for _, field := range entity.Fields {
			qtType := g.qtType(field.Type)
			propName := ToCamelCase(field.Name)
			memberName := "m_" + propName

			// Getter
			sb.WriteString(fmt.Sprintf("%s %s::%s() const\n", qtType, className, propName))
			sb.WriteString("{\n")
			sb.WriteString(fmt.Sprintf("    return %s;\n", memberName))
			sb.WriteString("}\n\n")

			// Setter
			sb.WriteString(fmt.Sprintf("void %s::set%s(%s value)\n", className, ToPascalCase(field.Name), qtType))
			sb.WriteString("{\n")
			sb.WriteString(fmt.Sprintf("    if (%s != value) {\n", memberName))
			sb.WriteString(fmt.Sprintf("        %s = value;\n", memberName))
			sb.WriteString(fmt.Sprintf("        emit %sChanged();\n", propName))
			sb.WriteString("    }\n")
			sb.WriteString("}\n\n")
		}
	}

	// Close namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("} // namespace %s\n", g.Namespace))
	}

	return sb.String()
}

func (g *QtGenerator) generateRepositoryHeader(entity *parser.EntityDecl) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	entityName := entity.Name
	guardName := strings.ToUpper(ToSnakeCase(className)) + "_H"

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("#ifndef %s\n", guardName))
	sb.WriteString(fmt.Sprintf("#define %s\n\n", guardName))

	// Includes
	sb.WriteString("#include <QObject>\n")
	sb.WriteString("#include <QSqlDatabase>\n")
	sb.WriteString("#include <QSqlQuery>\n")
	sb.WriteString("#include <QList>\n")
	sb.WriteString("#include <optional>\n")
	sb.WriteString(fmt.Sprintf("#include \"%s.h\"\n\n", ToSnakeCase(entityName)))

	// Namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("namespace %s {\n\n", g.Namespace))
	}

	// Class declaration
	sb.WriteString(fmt.Sprintf("class %s : public QObject\n", className))
	sb.WriteString("{\n")
	sb.WriteString("    Q_OBJECT\n\n")

	sb.WriteString("public:\n")
	sb.WriteString(fmt.Sprintf("    explicit %s(QSqlDatabase db, QObject *parent = nullptr);\n", className))
	sb.WriteString(fmt.Sprintf("    ~%s() override = default;\n\n", className))

	// CRUD methods
	sb.WriteString(fmt.Sprintf("    void upsert(%s *entity);\n", entityName))

	// Find by ID
	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}
	if pkField != nil {
		pkType := g.qtType(pkField.Type)
		sb.WriteString(fmt.Sprintf("    %s* findById(%s id, QObject *parent = nullptr);\n", entityName, pkType))
	}

	sb.WriteString(fmt.Sprintf("    QList<%s*> findAll(QObject *parent = nullptr);\n", entityName))
	if pkField != nil {
		pkType := g.qtType(pkField.Type)
		sb.WriteString(fmt.Sprintf("    bool remove(%s id);\n\n", pkType))
	}

	// Query methods
	for _, query := range entity.Queries {
		sb.WriteString(g.generateQueryMethodDeclaration(entity, query))
	}

	sb.WriteString("\nprivate:\n")
	sb.WriteString(fmt.Sprintf("    %s* mapRow(const QSqlQuery &query, QObject *parent);\n", entityName))
	sb.WriteString("    QSqlDatabase m_db;\n")

	sb.WriteString("};\n\n")

	// Close namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("} // namespace %s\n\n", g.Namespace))
	}

	sb.WriteString(fmt.Sprintf("#endif // %s\n", guardName))

	return sb.String()
}

func (g *QtGenerator) generateRepositorySource(entity *parser.EntityDecl) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	headerName := ToSnakeCase(className) + ".h"

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("#include \"%s\"\n", headerName))
	sb.WriteString("#include <QSqlError>\n")
	sb.WriteString("#include <QVariant>\n\n")

	// Namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("namespace %s {\n\n", g.Namespace))
	}

	// Constructor
	sb.WriteString(fmt.Sprintf("%s::%s(QSqlDatabase db, QObject *parent)\n", className, className))
	sb.WriteString("    : QObject(parent)\n")
	sb.WriteString("    , m_db(db)\n")
	sb.WriteString("{\n}\n\n")

	// Upsert
	sb.WriteString(g.generateQtUpsert(entity, tableName))

	// Find by ID
	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}
	if pkField != nil {
		sb.WriteString(g.generateQtFindById(entity, tableName, pkField))
	}

	// Find all
	sb.WriteString(g.generateQtFindAll(entity, tableName))

	// Delete
	if pkField != nil {
		sb.WriteString(g.generateQtDelete(entity, tableName, pkField))
	}

	// Query methods
	for _, query := range entity.Queries {
		sb.WriteString(g.generateQtQueryMethod(entity, query, tableName))
	}

	// Row mapper
	sb.WriteString(g.generateQtRowMapper(entity))

	// Close namespace
	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("} // namespace %s\n", g.Namespace))
	}

	return sb.String()
}

func (g *QtGenerator) generateQtUpsert(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	entityName := entity.Name

	var columns []string
	var placeholders []string
	for _, field := range entity.Fields {
		columns = append(columns, ToSnakeCase(field.Name))
		placeholders = append(placeholders, "?")
	}

	sb.WriteString(fmt.Sprintf("void %s::upsert(%s *entity)\n", className, entityName))
	sb.WriteString("{\n")
	sb.WriteString("    QSqlQuery query(m_db);\n")
	sb.WriteString(fmt.Sprintf("    query.prepare(\"INSERT OR REPLACE INTO %s (%s) VALUES (%s)\");\n",
		tableName, strings.Join(columns, ", "), strings.Join(placeholders, ", ")))

	for _, field := range entity.Fields {
		propName := ToCamelCase(field.Name)
		sb.WriteString(fmt.Sprintf("    query.addBindValue(entity->%s());\n", propName))
	}

	sb.WriteString("    query.exec();\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *QtGenerator) generateQtFindById(entity *parser.EntityDecl, tableName string, pkField *parser.FieldDecl) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	entityName := entity.Name
	pkType := g.qtType(pkField.Type)
	pkCol := ToSnakeCase(pkField.Name)

	sb.WriteString(fmt.Sprintf("%s* %s::findById(%s id, QObject *parent)\n", entityName, className, pkType))
	sb.WriteString("{\n")
	sb.WriteString("    QSqlQuery query(m_db);\n")
	sb.WriteString(fmt.Sprintf("    query.prepare(\"SELECT * FROM %s WHERE %s = ?\");\n", tableName, pkCol))
	sb.WriteString("    query.addBindValue(id);\n")
	sb.WriteString("    query.exec();\n\n")
	sb.WriteString("    if (query.next()) {\n")
	sb.WriteString("        return mapRow(query, parent);\n")
	sb.WriteString("    }\n")
	sb.WriteString("    return nullptr;\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *QtGenerator) generateQtFindAll(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	entityName := entity.Name

	sb.WriteString(fmt.Sprintf("QList<%s*> %s::findAll(QObject *parent)\n", entityName, className))
	sb.WriteString("{\n")
	sb.WriteString(fmt.Sprintf("    QList<%s*> results;\n", entityName))
	sb.WriteString("    QSqlQuery query(m_db);\n")
	sb.WriteString(fmt.Sprintf("    query.exec(\"SELECT * FROM %s\");\n\n", tableName))
	sb.WriteString("    while (query.next()) {\n")
	sb.WriteString("        results.append(mapRow(query, parent));\n")
	sb.WriteString("    }\n")
	sb.WriteString("    return results;\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *QtGenerator) generateQtDelete(entity *parser.EntityDecl, tableName string, pkField *parser.FieldDecl) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	pkType := g.qtType(pkField.Type)
	pkCol := ToSnakeCase(pkField.Name)

	sb.WriteString(fmt.Sprintf("bool %s::remove(%s id)\n", className, pkType))
	sb.WriteString("{\n")
	sb.WriteString("    QSqlQuery query(m_db);\n")
	sb.WriteString(fmt.Sprintf("    query.prepare(\"DELETE FROM %s WHERE %s = ?\");\n", tableName, pkCol))
	sb.WriteString("    query.addBindValue(id);\n")
	sb.WriteString("    return query.exec() && query.numRowsAffected() > 0;\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *QtGenerator) generateQueryMethodDeclaration(entity *parser.EntityDecl, query *parser.QueryDecl) string {
	var sb strings.Builder
	entityName := entity.Name
	methodName := ToCamelCase(query.Name)

	sb.WriteString(fmt.Sprintf("    QList<%s*> %s(", entityName, methodName))

	var params []string
	for _, p := range query.Params {
		qtType := g.qtType(p.Type)
		paramName := ToCamelCase(p.Name)
		if p.Default != nil {
			params = append(params, fmt.Sprintf("%s %s = %s",
				qtType, paramName, g.qtLiteralValue(p.Default, p.Type.Name)))
		} else {
			params = append(params, fmt.Sprintf("%s %s", qtType, paramName))
		}
	}
	params = append(params, "QObject *parent = nullptr")
	sb.WriteString(strings.Join(params, ", "))
	sb.WriteString(");\n")

	return sb.String()
}

func (g *QtGenerator) generateQtQueryMethod(entity *parser.EntityDecl, query *parser.QueryDecl, tableName string) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	entityName := entity.Name
	methodName := ToCamelCase(query.Name)

	// Method signature
	sb.WriteString(fmt.Sprintf("QList<%s*> %s::%s(", entityName, className, methodName))

	var params []string
	for _, p := range query.Params {
		qtType := g.qtType(p.Type)
		paramName := ToCamelCase(p.Name)
		params = append(params, fmt.Sprintf("%s %s", qtType, paramName))
	}
	params = append(params, "QObject *parent")
	sb.WriteString(strings.Join(params, ", "))
	sb.WriteString(")\n{\n")

	// Build SQL
	var sqlParts []string
	sqlParts = append(sqlParts, fmt.Sprintf("SELECT * FROM %s", tableName))

	if query.Where != nil {
		whereSQL, _ := ExprToSQLWithParams(query.Where, "")
		sqlParts = append(sqlParts, "WHERE "+whereSQL)
	}

	if len(query.OrderBy) > 0 {
		var orderParts []string
		for _, o := range query.OrderBy {
			dir := "ASC"
			if o.Descending {
				dir = "DESC"
			}
			orderParts = append(orderParts, fmt.Sprintf("%s %s", ToSnakeCase(o.Field), dir))
		}
		sqlParts = append(sqlParts, "ORDER BY "+strings.Join(orderParts, ", "))
	}

	if query.Limit != nil {
		if _, ok := query.Limit.(*parser.IdentExpr); ok {
			sqlParts = append(sqlParts, "LIMIT ?")
		} else if lit, ok := query.Limit.(*parser.LiteralExpr); ok {
			if val, ok := lit.Value.(int64); ok {
				sqlParts = append(sqlParts, fmt.Sprintf("LIMIT %d", val))
			}
		}
	}

	sb.WriteString(fmt.Sprintf("    QList<%s*> results;\n", entityName))
	sb.WriteString("    QSqlQuery query(m_db);\n")
	sb.WriteString(fmt.Sprintf("    query.prepare(\"%s\");\n", strings.Join(sqlParts, " ")))

	// Bind parameters
	for _, p := range query.Params {
		paramName := ToCamelCase(p.Name)
		sb.WriteString(fmt.Sprintf("    query.addBindValue(%s);\n", paramName))
	}

	// Handle limit if it's a parameter
	if query.Limit != nil {
		if l, ok := query.Limit.(*parser.IdentExpr); ok {
			sb.WriteString(fmt.Sprintf("    query.addBindValue(%s);\n", ToCamelCase(l.Name)))
		}
	}

	sb.WriteString("    query.exec();\n\n")
	sb.WriteString("    while (query.next()) {\n")
	sb.WriteString("        results.append(mapRow(query, parent));\n")
	sb.WriteString("    }\n")
	sb.WriteString("    return results;\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *QtGenerator) generateQtRowMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder
	className := entity.Name + "Repository"
	entityName := entity.Name

	sb.WriteString(fmt.Sprintf("%s* %s::mapRow(const QSqlQuery &query, QObject *parent)\n",
		entityName, className))
	sb.WriteString("{\n")
	sb.WriteString(fmt.Sprintf("    return %s::create(\n", entityName))

	var mapperLines []string
	for i, field := range entity.Fields {
		colName := ToSnakeCase(field.Name)
		getter := g.qtQueryGetter(field, i)
		mapperLines = append(mapperLines, fmt.Sprintf("        query.value(\"%s\")%s", colName, getter))
	}
	sb.WriteString(strings.Join(mapperLines, ",\n"))
	sb.WriteString(",\n        parent\n")
	sb.WriteString("    );\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

func (g *QtGenerator) generateEnumHeader(enum *parser.EnumDecl) string {
	var sb strings.Builder
	guardName := strings.ToUpper(ToSnakeCase(enum.Name)) + "_H"

	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("#ifndef %s\n", guardName))
	sb.WriteString(fmt.Sprintf("#define %s\n\n", guardName))

	sb.WriteString("#include <QObject>\n\n")

	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("namespace %s {\n\n", g.Namespace))
	}

	sb.WriteString("Q_NAMESPACE\n\n")
	sb.WriteString(fmt.Sprintf("enum class %s {\n", enum.Name))

	for _, val := range enum.Values {
		sb.WriteString(fmt.Sprintf("    %s = %d,\n", val.Name, val.Number))
	}

	sb.WriteString("};\n")
	sb.WriteString(fmt.Sprintf("Q_ENUM_NS(%s)\n\n", enum.Name))

	if g.Namespace != "" {
		sb.WriteString(fmt.Sprintf("} // namespace %s\n\n", g.Namespace))
	}

	sb.WriteString(fmt.Sprintf("#endif // %s\n", guardName))

	return sb.String()
}

func (g *QtGenerator) generateCMakeLists(file *parser.File) string {
	var sb strings.Builder

	sb.WriteString("# Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("cmake_minimum_required(VERSION 3.16)\n\n")

	projectName := "dataproto_models"
	if file.Package != nil {
		projectName = strings.ReplaceAll(file.Package.Name, ".", "_") + "_models"
	}

	sb.WriteString(fmt.Sprintf("project(%s LANGUAGES CXX)\n\n", projectName))
	sb.WriteString("set(CMAKE_CXX_STANDARD 17)\n")
	sb.WriteString("set(CMAKE_CXX_STANDARD_REQUIRED ON)\n")
	sb.WriteString("set(CMAKE_AUTOMOC ON)\n\n")

	sb.WriteString("find_package(Qt6 REQUIRED COMPONENTS Core Sql)\n")
	if g.GenerateQML {
		sb.WriteString("find_package(Qt6 REQUIRED COMPONENTS Qml)\n")
	}
	sb.WriteString("\n")

	// Source files
	sb.WriteString("set(SOURCES\n")
	for _, entity := range file.Entities {
		baseName := ToSnakeCase(entity.Name)
		sb.WriteString(fmt.Sprintf("    %s.cpp\n", baseName))
		sb.WriteString(fmt.Sprintf("    %s.h\n", baseName))
		if g.GenerateRepository {
			sb.WriteString(fmt.Sprintf("    %s_repository.cpp\n", baseName))
			sb.WriteString(fmt.Sprintf("    %s_repository.h\n", baseName))
		}
	}
	for _, enum := range file.Enums {
		sb.WriteString(fmt.Sprintf("    %s.h\n", ToSnakeCase(enum.Name)))
	}
	sb.WriteString(")\n\n")

	sb.WriteString(fmt.Sprintf("add_library(%s ${SOURCES})\n\n", projectName))

	sb.WriteString(fmt.Sprintf("target_link_libraries(%s PRIVATE\n", projectName))
	sb.WriteString("    Qt6::Core\n")
	sb.WriteString("    Qt6::Sql\n")
	if g.GenerateQML {
		sb.WriteString("    Qt6::Qml\n")
	}
	sb.WriteString(")\n")

	return sb.String()
}

// Helper methods

func (g *QtGenerator) qtType(typeRef *parser.TypeRef) string {
	baseType := g.qtBaseType(typeRef.Name)
	// Qt uses value types, optionals handled differently
	return baseType
}

func (g *QtGenerator) qtBaseType(typeName string) string {
	switch typeName {
	case "string":
		return "QString"
	case "int32":
		return "int"
	case "int64", "timestamp":
		return "qint64"
	case "float":
		return "float"
	case "double":
		return "double"
	case "bool":
		return "bool"
	case "bytes":
		return "QByteArray"
	default:
		return typeName
	}
}

func (g *QtGenerator) qtDefaultValue(field *parser.FieldDecl) string {
	if def := field.GetAnnotation("default"); def != nil && len(def.Args) > 0 {
		return g.qtLiteralValue(def.Args[0].Value, field.Type.Name)
	}

	switch field.Type.Name {
	case "string":
		return "QString()"
	case "int32":
		return "0"
	case "int64", "timestamp":
		return "0"
	case "float", "double":
		return "0.0"
	case "bool":
		return "false"
	case "bytes":
		return "QByteArray()"
	default:
		return "{}"
	}
}

func (g *QtGenerator) qtLiteralValue(value interface{}, typeName string) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("QStringLiteral(\"%s\")", v)
	case bool:
		if v {
			return "true"
		}
		return "false"
	case int64:
		return fmt.Sprintf("%d", v)
	case float64:
		return fmt.Sprintf("%f", v)
	default:
		return g.qtDefaultValue(&parser.FieldDecl{Type: &parser.TypeRef{Name: typeName}})
	}
}

func (g *QtGenerator) qtQueryGetter(field *parser.FieldDecl, index int) string {
	switch field.Type.Name {
	case "string":
		return ".toString()"
	case "int32":
		return ".toInt()"
	case "int64", "timestamp":
		return ".toLongLong()"
	case "float":
		return ".toFloat()"
	case "double":
		return ".toDouble()"
	case "bool":
		return ".toBool()"
	case "bytes":
		return ".toByteArray()"
	default:
		return ".toString()"
	}
}
