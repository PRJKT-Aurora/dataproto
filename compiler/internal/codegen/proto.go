package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// ProtoGenerator generates .proto files from DataProto schemas.
type ProtoGenerator struct {
	PackagePrefix string // Optional package prefix
}

// NewProtoGenerator creates a new ProtoGenerator.
func NewProtoGenerator() *ProtoGenerator {
	return &ProtoGenerator{}
}

// Generate generates .proto file content from a DataProto file.
func (g *ProtoGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n")
	sb.WriteString("// source: ")
	if file.Package != nil {
		sb.WriteString(file.Package.Name)
	}
	sb.WriteString(".dataproto\n\n")

	sb.WriteString("syntax = \"proto3\";\n\n")

	// Package
	if file.Package != nil {
		packageName := file.Package.Name
		if g.PackagePrefix != "" {
			packageName = g.PackagePrefix + "." + packageName
		}
		sb.WriteString(fmt.Sprintf("package %s;\n\n", packageName))
	}

	// Options
	for _, opt := range file.Options {
		sb.WriteString(g.generateOption(opt))
	}
	if len(file.Options) > 0 {
		sb.WriteString("\n")
	}

	// Enums
	for _, enum := range file.Enums {
		sb.WriteString(g.generateEnum(enum))
		sb.WriteString("\n")
	}

	// Messages (from entities)
	for _, entity := range file.Entities {
		sb.WriteString(g.generateMessage(entity))
		sb.WriteString("\n")
	}

	// Services
	for _, svc := range file.Services {
		sb.WriteString(g.generateService(svc))
		sb.WriteString("\n")
	}

	// Generate supporting messages referenced by services (request/response types)
	supportingTypes := g.collectSupportingTypes(file)
	if len(supportingTypes) > 0 {
		sb.WriteString(supportingTypes)
	}

	// Generate filename
	filename := "output.proto"
	if file.Package != nil {
		parts := strings.Split(file.Package.Name, ".")
		filename = parts[len(parts)-1] + ".proto"
	}

	result[filename] = sb.String()
	return result, nil
}

func (g *ProtoGenerator) generateOption(opt *parser.OptionDecl) string {
	var value string
	switch v := opt.Value.(type) {
	case string:
		value = fmt.Sprintf("\"%s\"", v)
	case bool:
		value = fmt.Sprintf("%t", v)
	case int64:
		value = fmt.Sprintf("%d", v)
	case float64:
		value = fmt.Sprintf("%f", v)
	default:
		value = fmt.Sprintf("%v", v)
	}
	return fmt.Sprintf("option %s = %s;\n", opt.Name, value)
}

func (g *ProtoGenerator) generateEnum(enum *parser.EnumDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("enum %s {\n", enum.Name))

	for _, val := range enum.Values {
		sb.WriteString(fmt.Sprintf("    %s = %d;\n", val.Name, val.Number))
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g *ProtoGenerator) generateMessage(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("message %s {\n", entity.Name))

	fieldNumber := 1
	for _, field := range entity.Fields {
		sb.WriteString(g.generateField(field, fieldNumber))
		fieldNumber++
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g *ProtoGenerator) generateField(field *parser.FieldDecl, number int) string {
	typeMapping := GetTypeMapping(field.Type.Name)
	protoType := typeMapping.Proto

	var prefix string
	if field.Type.Optional {
		prefix = "optional "
	}

	// Convert field name to proto style (snake_case)
	fieldName := ToSnakeCase(field.Name)

	return fmt.Sprintf("    %s%s %s = %d;\n", prefix, protoType, fieldName, number)
}

func (g *ProtoGenerator) generateService(svc *parser.ServiceDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("service %s {\n", svc.Name))

	for _, method := range svc.Methods {
		sb.WriteString(g.generateRpc(method))
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g *ProtoGenerator) generateRpc(rpc *parser.RpcDecl) string {
	reqType := rpc.RequestType.Name
	if rpc.RequestType.Stream {
		reqType = "stream " + reqType
	}

	respType := rpc.ResponseType.Name
	if rpc.ResponseType.Stream {
		respType = "stream " + respType
	}

	return fmt.Sprintf("    rpc %s(%s) returns (%s);\n",
		rpc.Name, reqType, respType)
}

// collectSupportingTypes generates message types referenced by services that aren't defined as entities.
func (g *ProtoGenerator) collectSupportingTypes(file *parser.File) string {
	// Collect all entity names (these are already defined)
	definedTypes := make(map[string]bool)
	for _, entity := range file.Entities {
		definedTypes[entity.Name] = true
	}

	// Collect all types referenced by services
	referencedTypes := make(map[string]bool)
	for _, svc := range file.Services {
		for _, method := range svc.Methods {
			reqType := method.RequestType.Name
			respType := method.ResponseType.Name
			if !definedTypes[reqType] {
				referencedTypes[reqType] = true
			}
			if !definedTypes[respType] {
				referencedTypes[respType] = true
			}
		}
	}

	if len(referencedTypes) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString("// Supporting message types for service methods\n\n")

	// Generate common types based on naming conventions
	for typeName := range referencedTypes {
		sb.WriteString(g.generateSupportingMessage(typeName, file))
		sb.WriteString("\n")
	}

	return sb.String()
}

// generateSupportingMessage generates a message definition for a service-referenced type.
func (g *ProtoGenerator) generateSupportingMessage(typeName string, file *parser.File) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("message %s {\n", typeName))

	// Infer fields based on common naming patterns
	switch {
	case typeName == "Result":
		sb.WriteString("    bool success = 1;\n")
		sb.WriteString("    optional string message = 2;\n")

	case typeName == "PushResult":
		sb.WriteString("    int32 inserted_count = 1;\n")
		sb.WriteString("    int32 updated_count = 2;\n")
		sb.WriteString("    repeated string failed_ids = 3;\n")

	case strings.HasPrefix(typeName, "Get") && strings.HasSuffix(typeName, "Request"):
		// GetXxxRequest - typically has filter parameters
		sb.WriteString("    optional int64 since = 1;\n")
		sb.WriteString("    optional int32 limit = 2;\n")
		sb.WriteString("    optional int32 offset = 3;\n")

	case strings.HasPrefix(typeName, "Delete") && strings.HasSuffix(typeName, "Request"):
		// DeleteXxxRequest - typically has an ID
		sb.WriteString("    string id = 1;\n")

	case strings.HasPrefix(typeName, "Clear") && strings.HasSuffix(typeName, "Request"):
		// ClearXxxRequest - optional confirmation
		sb.WriteString("    bool confirm = 1;\n")

	case strings.HasPrefix(typeName, "Complete") && strings.HasSuffix(typeName, "Request"):
		// CompleteXxxRequest - ID of item to mark complete
		sb.WriteString("    string id = 1;\n")

	default:
		// Unknown type - generate empty message
		sb.WriteString("    // TODO: Define fields for " + typeName + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

// GenerateRequestMessages generates request/response message types for queries.
func (g *ProtoGenerator) GenerateRequestMessages(entity *parser.EntityDecl) string {
	var sb strings.Builder

	for _, query := range entity.Queries {
		// Request message
		sb.WriteString(fmt.Sprintf("message %s%sRequest {\n",
			entity.Name, ToPascalCase(query.Name)))

		fieldNumber := 1
		for _, param := range query.Params {
			typeMapping := GetTypeMapping(param.Type.Name)
			protoType := typeMapping.Proto

			var prefix string
			if param.Type.Optional || param.Default != nil {
				prefix = "optional "
			}

			sb.WriteString(fmt.Sprintf("    %s%s %s = %d;\n",
				prefix, protoType, ToSnakeCase(param.Name), fieldNumber))
			fieldNumber++
		}

		sb.WriteString("}\n\n")

		// Response message (list of entities)
		sb.WriteString(fmt.Sprintf("message %s%sResponse {\n",
			entity.Name, ToPascalCase(query.Name)))
		sb.WriteString(fmt.Sprintf("    repeated %s items = 1;\n", entity.Name))
		sb.WriteString("}\n\n")
	}

	return sb.String()
}
