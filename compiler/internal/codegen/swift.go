package codegen

import (
	"fmt"
	"strings"

	"github.com/aurora/dataproto/internal/parser"
)

// SwiftGenerator generates Swift code from DataProto schemas.
type SwiftGenerator struct {
	ModuleName         string // Swift module name
	GenerateMappers    bool   // Generate iOS native type mappers (EKEvent, etc.)
	GenerateRepository bool   // Generate local storage repository
	UseCertification   bool   // Include certification check
}

// NewSwiftGenerator creates a new SwiftGenerator with defaults.
func NewSwiftGenerator() *SwiftGenerator {
	return &SwiftGenerator{
		ModuleName:         "DataProto",
		GenerateMappers:    true,
		GenerateRepository: true,
		UseCertification:   true,
	}
}

// Generate generates Swift code from a DataProto file.
func (g *SwiftGenerator) Generate(file *parser.File) (map[string]string, error) {
	result := make(map[string]string)

	for _, entity := range file.Entities {
		// Entity struct
		entityCode := g.generateEntity(entity)
		result[entity.Name+".swift"] = entityCode

		// Mapper (proto <-> entity, iOS native types)
		if g.GenerateMappers {
			mapperCode := g.generateMapper(entity)
			result[entity.Name+"Mapper.swift"] = mapperCode
		}

		// Repository
		if g.GenerateRepository {
			repoCode := g.generateRepository(entity)
			result[entity.Name+"Repository.swift"] = repoCode
		}
	}

	// Generate query builders
	queryBuilderCode := g.generateQueryBuilder(file)
	result["QueryBuilder.swift"] = queryBuilderCode

	return result, nil
}

func (g *SwiftGenerator) generateEntity(entity *parser.EntityDecl) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("import Foundation\n\n")

	// Struct
	sb.WriteString(fmt.Sprintf("public struct %s: Codable, Identifiable, Sendable {\n", entity.Name))

	// Properties
	for _, field := range entity.Fields {
		swiftType := g.swiftType(field.Type)
		propertyName := ToCamelCase(field.Name)

		// Add documentation comment if it's a special field
		if field.IsPrimaryKey() {
			sb.WriteString("    /// Primary key\n")
		}

		sb.WriteString(fmt.Sprintf("    public var %s: %s\n", propertyName, swiftType))
	}

	sb.WriteString("\n")

	// Identifiable conformance (use primary key)
	// Only add computed id property if the primary key is NOT already named "id"
	for _, field := range entity.Fields {
		if field.IsPrimaryKey() {
			pkName := ToCamelCase(field.Name)
			if pkName != "id" {
				sb.WriteString(fmt.Sprintf("    public var id: String { %s }\n", pkName))
				sb.WriteString("\n")
			}
			break
		}
	}

	// Memberwise initializer
	sb.WriteString("    public init(\n")
	var initParams []string
	for _, field := range entity.Fields {
		swiftType := g.swiftType(field.Type)
		propertyName := ToCamelCase(field.Name)

		defaultValue := ""
		if field.Type.Optional {
			defaultValue = " = nil"
		} else if def := field.GetAnnotation("default"); def != nil && len(def.Args) > 0 {
			defaultValue = " = " + g.swiftDefaultValue(def.Args[0].Value, field.Type.Name)
		}

		initParams = append(initParams, fmt.Sprintf("        %s: %s%s",
			propertyName, swiftType, defaultValue))
	}
	sb.WriteString(strings.Join(initParams, ",\n"))
	sb.WriteString("\n    ) {\n")

	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		sb.WriteString(fmt.Sprintf("        self.%s = %s\n", propertyName, propertyName))
	}
	sb.WriteString("    }\n")

	sb.WriteString("}\n")

	return sb.String()
}

func (g *SwiftGenerator) generateMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("import Foundation\n")

	// Check for iOS-specific imports based on entity name
	needsEventKit := strings.Contains(entity.Name, "Calendar") || strings.Contains(entity.Name, "Event")
	needsReminders := strings.Contains(entity.Name, "Reminder")
	needsPhotos := strings.Contains(entity.Name, "Photo")

	if needsEventKit {
		sb.WriteString("import EventKit\n")
	}
	if needsReminders && !needsEventKit {
		sb.WriteString("import EventKit\n")
	}
	if needsPhotos {
		sb.WriteString("import Photos\n")
	}
	sb.WriteString("\n")

	// Mapper extension
	sb.WriteString(fmt.Sprintf("public extension %s {\n\n", entity.Name))

	// From proto
	sb.WriteString(fmt.Sprintf("    /// Creates a %s from its protobuf representation\n", entity.Name))
	sb.WriteString(fmt.Sprintf("    init(proto: %sProto) {\n", entity.Name))
	sb.WriteString("        self.init(\n")

	var protoInits []string
	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		protoGetter := g.protoGetter(field)
		protoInits = append(protoInits, fmt.Sprintf("            %s: %s", propertyName, protoGetter))
	}
	sb.WriteString(strings.Join(protoInits, ",\n"))
	sb.WriteString("\n        )\n")
	sb.WriteString("    }\n\n")

	// To proto
	sb.WriteString(fmt.Sprintf("    /// Converts to protobuf representation\n"))
	sb.WriteString(fmt.Sprintf("    func toProto() -> %sProto {\n", entity.Name))
	sb.WriteString(fmt.Sprintf("        var proto = %sProto()\n", entity.Name))

	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		protoSetter := g.protoSetter(field, propertyName)
		sb.WriteString(fmt.Sprintf("        %s\n", protoSetter))
	}

	sb.WriteString("        return proto\n")
	sb.WriteString("    }\n")

	// iOS native type mappers
	if needsEventKit && strings.Contains(entity.Name, "Calendar") {
		sb.WriteString(g.generateEKEventMapper(entity))
	}
	if needsReminders {
		sb.WriteString(g.generateEKReminderMapper(entity))
	}
	if needsPhotos {
		sb.WriteString(g.generatePHAssetMapper(entity))
	}

	sb.WriteString("}\n")

	return sb.String()
}

func (g *SwiftGenerator) generateEKEventMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString("\n")
	sb.WriteString("    /// Creates from an EventKit event\n")
	sb.WriteString("    init(ekEvent: EKEvent) {\n")
	sb.WriteString("        self.init(\n")

	// Map common fields
	mappings := map[string]string{
		"id":            "ekEvent.eventIdentifier",
		"title":         "ekEvent.title ?? \"\"",
		"startDate":     "Int64(ekEvent.startDate.timeIntervalSince1970 * 1000)",
		"endDate":       "ekEvent.endDate.map { Int64($0.timeIntervalSince1970 * 1000) }",
		"isAllDay":      "ekEvent.isAllDay",
		"location":      "ekEvent.location",
		"notes":         "ekEvent.notes",
		"calendarName":  "ekEvent.calendar?.title",
		"calendarColor": "ekEvent.calendar?.cgColor.map { UIColor(cgColor: $0).hexString }",
	}

	var initParams []string
	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		if mapping, ok := mappings[propertyName]; ok {
			initParams = append(initParams, fmt.Sprintf("            %s: %s", propertyName, mapping))
		} else {
			// Default value for unmapped fields
			if field.Type.Optional {
				initParams = append(initParams, fmt.Sprintf("            %s: nil", propertyName))
			} else {
				initParams = append(initParams, fmt.Sprintf("            %s: %s",
					propertyName, g.swiftDefaultForType(field.Type.Name)))
			}
		}
	}

	sb.WriteString(strings.Join(initParams, ",\n"))
	sb.WriteString("\n        )\n")
	sb.WriteString("    }\n")

	return sb.String()
}

func (g *SwiftGenerator) generateEKReminderMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString("\n")
	sb.WriteString("    /// Creates from an EventKit reminder\n")
	sb.WriteString("    init(ekReminder: EKReminder) {\n")
	sb.WriteString("        self.init(\n")

	mappings := map[string]string{
		"id":          "ekReminder.calendarItemIdentifier",
		"title":       "ekReminder.title ?? \"\"",
		"dueDate":     "ekReminder.dueDateComponents?.date.map { Int64($0.timeIntervalSince1970 * 1000) }",
		"isCompleted": "ekReminder.isCompleted",
		"priority":    "Int32(ekReminder.priority)",
		"listName":    "ekReminder.calendar?.title",
		"notes":       "ekReminder.notes",
	}

	var initParams []string
	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		if mapping, ok := mappings[propertyName]; ok {
			initParams = append(initParams, fmt.Sprintf("            %s: %s", propertyName, mapping))
		} else {
			if field.Type.Optional {
				initParams = append(initParams, fmt.Sprintf("            %s: nil", propertyName))
			} else {
				initParams = append(initParams, fmt.Sprintf("            %s: %s",
					propertyName, g.swiftDefaultForType(field.Type.Name)))
			}
		}
	}

	sb.WriteString(strings.Join(initParams, ",\n"))
	sb.WriteString("\n        )\n")
	sb.WriteString("    }\n")

	return sb.String()
}

func (g *SwiftGenerator) generatePHAssetMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString("\n")
	sb.WriteString("    /// Creates from a Photos asset\n")
	sb.WriteString("    init(phAsset: PHAsset) {\n")
	sb.WriteString("        self.init(\n")

	mappings := map[string]string{
		"localIdentifier": "phAsset.localIdentifier",
		"createdDate":     "phAsset.creationDate.map { Int64($0.timeIntervalSince1970 * 1000) }",
		"width":           "Int32(phAsset.pixelWidth)",
		"height":          "Int32(phAsset.pixelHeight)",
		"isFavorite":      "phAsset.isFavorite",
		"mediaType":       "MediaType(phAsset: phAsset)",
		"latitude":        "phAsset.location?.coordinate.latitude",
		"longitude":       "phAsset.location?.coordinate.longitude",
	}

	var initParams []string
	for _, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		if mapping, ok := mappings[propertyName]; ok {
			initParams = append(initParams, fmt.Sprintf("            %s: %s", propertyName, mapping))
		} else {
			if field.Type.Optional {
				initParams = append(initParams, fmt.Sprintf("            %s: nil", propertyName))
			} else {
				initParams = append(initParams, fmt.Sprintf("            %s: %s",
					propertyName, g.swiftDefaultForType(field.Type.Name)))
			}
		}
	}

	sb.WriteString(strings.Join(initParams, ",\n"))
	sb.WriteString("\n        )\n")
	sb.WriteString("    }\n")

	return sb.String()
}

func (g *SwiftGenerator) generateRepository(entity *parser.EntityDecl) string {
	var sb strings.Builder

	tableName := entity.TableName()
	if tableName == "" {
		tableName = ToSnakeCase(entity.Name)
	}

	// Header
	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("import Foundation\n")
	sb.WriteString("import SQLite3\n\n")

	// Actor for thread safety
	sb.WriteString(fmt.Sprintf("public actor %sRepository {\n\n", entity.Name))

	sb.WriteString("    private let db: OpaquePointer\n\n")

	// Init
	sb.WriteString("    public init(databasePath: String) throws {\n")
	sb.WriteString("        var db: OpaquePointer?\n")
	sb.WriteString("        guard sqlite3_open(databasePath, &db) == SQLITE_OK else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(\"Failed to open database\")\n")
	sb.WriteString("        }\n")
	sb.WriteString("        self.db = db!\n")
	sb.WriteString("    }\n\n")

	// Deinit
	sb.WriteString("    deinit {\n")
	sb.WriteString("        sqlite3_close(db)\n")
	sb.WriteString("    }\n\n")

	// CRUD methods
	sb.WriteString(g.generateSwiftUpsert(entity, tableName))
	sb.WriteString(g.generateSwiftFindById(entity, tableName))
	sb.WriteString(g.generateSwiftFindAll(entity, tableName))
	sb.WriteString(g.generateSwiftDelete(entity, tableName))

	// Query methods
	for _, query := range entity.Queries {
		sb.WriteString(g.generateSwiftQueryMethod(entity, query, tableName))
	}

	// Row mapper
	sb.WriteString(g.generateSwiftRowMapper(entity))

	sb.WriteString("}\n\n")

	// Error enum
	sb.WriteString("public enum DataProtoError: Error {\n")
	sb.WriteString("    case databaseError(String)\n")
	sb.WriteString("    case notFound\n")
	sb.WriteString("}\n")

	return sb.String()
}

func (g *SwiftGenerator) generateSwiftUpsert(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	var columns []string
	var placeholders []string
	for _, field := range entity.Fields {
		columns = append(columns, ToSnakeCase(field.Name))
		placeholders = append(placeholders, "?")
	}

	sb.WriteString(fmt.Sprintf("    public func upsert(_ entity: %s) throws {\n", entity.Name))
	sb.WriteString(fmt.Sprintf("        let sql = \"INSERT OR REPLACE INTO %s (%s) VALUES (%s)\"\n",
		tableName, strings.Join(columns, ", "), strings.Join(placeholders, ", ")))
	sb.WriteString("        var stmt: OpaquePointer?\n")
	sb.WriteString("        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(String(cString: sqlite3_errmsg(db)))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        defer { sqlite3_finalize(stmt) }\n\n")

	for i, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		binding := g.swiftSQLiteBinding(field, i+1, "entity."+propertyName)
		sb.WriteString(fmt.Sprintf("        %s\n", binding))
	}

	sb.WriteString("\n        guard sqlite3_step(stmt) == SQLITE_DONE else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(String(cString: sqlite3_errmsg(db)))\n")
	sb.WriteString("        }\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *SwiftGenerator) generateSwiftFindById(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}

	if pkField == nil {
		return ""
	}

	pkType := g.swiftType(pkField.Type)
	pkName := ToCamelCase(pkField.Name)
	pkCol := ToSnakeCase(pkField.Name)

	sb.WriteString(fmt.Sprintf("    public func findById(_ %s: %s) throws -> %s? {\n",
		pkName, pkType, entity.Name))
	sb.WriteString(fmt.Sprintf("        let sql = \"SELECT * FROM %s WHERE %s = ?\"\n",
		tableName, pkCol))
	sb.WriteString("        var stmt: OpaquePointer?\n")
	sb.WriteString("        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(String(cString: sqlite3_errmsg(db)))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        defer { sqlite3_finalize(stmt) }\n\n")
	sb.WriteString(fmt.Sprintf("        sqlite3_bind_text(stmt, 1, %s, -1, nil)\n\n", pkName))
	sb.WriteString("        if sqlite3_step(stmt) == SQLITE_ROW {\n")
	sb.WriteString("            return mapRow(stmt)\n")
	sb.WriteString("        }\n")
	sb.WriteString("        return nil\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *SwiftGenerator) generateSwiftFindAll(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("    public func findAll() throws -> [%s] {\n", entity.Name))
	sb.WriteString(fmt.Sprintf("        let sql = \"SELECT * FROM %s\"\n", tableName))
	sb.WriteString("        var stmt: OpaquePointer?\n")
	sb.WriteString("        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(String(cString: sqlite3_errmsg(db)))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        defer { sqlite3_finalize(stmt) }\n\n")
	sb.WriteString(fmt.Sprintf("        var results: [%s] = []\n", entity.Name))
	sb.WriteString("        while sqlite3_step(stmt) == SQLITE_ROW {\n")
	sb.WriteString("            results.append(mapRow(stmt))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        return results\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *SwiftGenerator) generateSwiftDelete(entity *parser.EntityDecl, tableName string) string {
	var sb strings.Builder

	var pkField *parser.FieldDecl
	for _, f := range entity.Fields {
		if f.IsPrimaryKey() {
			pkField = f
			break
		}
	}

	if pkField == nil {
		return ""
	}

	pkType := g.swiftType(pkField.Type)
	pkName := ToCamelCase(pkField.Name)
	pkCol := ToSnakeCase(pkField.Name)

	sb.WriteString(fmt.Sprintf("    public func delete(_ %s: %s) throws -> Bool {\n",
		pkName, pkType))
	sb.WriteString(fmt.Sprintf("        let sql = \"DELETE FROM %s WHERE %s = ?\"\n",
		tableName, pkCol))
	sb.WriteString("        var stmt: OpaquePointer?\n")
	sb.WriteString("        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(String(cString: sqlite3_errmsg(db)))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        defer { sqlite3_finalize(stmt) }\n\n")
	sb.WriteString(fmt.Sprintf("        sqlite3_bind_text(stmt, 1, %s, -1, nil)\n\n", pkName))
	sb.WriteString("        return sqlite3_step(stmt) == SQLITE_DONE && sqlite3_changes(db) > 0\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *SwiftGenerator) generateSwiftQueryMethod(entity *parser.EntityDecl, query *parser.QueryDecl, tableName string) string {
	var sb strings.Builder

	// Method signature
	sb.WriteString(fmt.Sprintf("    public func %s(", ToCamelCase(query.Name)))

	var params []string
	for _, p := range query.Params {
		swiftType := g.swiftType(p.Type)
		paramName := ToCamelCase(p.Name)
		if p.Default != nil {
			params = append(params, fmt.Sprintf("%s: %s = %s",
				paramName, swiftType, g.swiftDefaultValue(p.Default, p.Type.Name)))
		} else {
			params = append(params, fmt.Sprintf("%s: %s", paramName, swiftType))
		}
	}
	sb.WriteString(strings.Join(params, ", "))
	sb.WriteString(fmt.Sprintf(") throws -> [%s] {\n", entity.Name))

	// Build SQL
	var sqlParts []string
	sqlParts = append(sqlParts, fmt.Sprintf("SELECT * FROM %s", tableName))

	if query.Where != nil {
		whereSQL, _ := ExprToSQLWithParams(query.Where, "")
		sqlParts = append(sqlParts, "WHERE "+whereSQL)
	}

	if len(query.OrderBy) > 0 {
		var orderParts []string
		for _, o := range query.OrderBy {
			dir := "ASC"
			if o.Descending {
				dir = "DESC"
			}
			orderParts = append(orderParts, fmt.Sprintf("%s %s", ToSnakeCase(o.Field), dir))
		}
		sqlParts = append(sqlParts, "ORDER BY "+strings.Join(orderParts, ", "))
	}

	if query.Limit != nil {
		if _, ok := query.Limit.(*parser.IdentExpr); ok {
			sqlParts = append(sqlParts, "LIMIT ?")
		} else if lit, ok := query.Limit.(*parser.LiteralExpr); ok {
			if val, ok := lit.Value.(int64); ok {
				sqlParts = append(sqlParts, fmt.Sprintf("LIMIT %d", val))
			}
		}
	}

	sb.WriteString(fmt.Sprintf("        let sql = \"%s\"\n", strings.Join(sqlParts, " ")))
	sb.WriteString("        var stmt: OpaquePointer?\n")
	sb.WriteString("        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {\n")
	sb.WriteString("            throw DataProtoError.databaseError(String(cString: sqlite3_errmsg(db)))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        defer { sqlite3_finalize(stmt) }\n\n")

	// Bind parameters
	paramIdx := 1
	for _, p := range query.Params {
		binding := g.swiftSQLiteBindingByType(p.Type.Name, paramIdx, ToCamelCase(p.Name))
		sb.WriteString(fmt.Sprintf("        %s\n", binding))
		paramIdx++
	}

	sb.WriteString(fmt.Sprintf("\n        var results: [%s] = []\n", entity.Name))
	sb.WriteString("        while sqlite3_step(stmt) == SQLITE_ROW {\n")
	sb.WriteString("            results.append(mapRow(stmt))\n")
	sb.WriteString("        }\n")
	sb.WriteString("        return results\n")
	sb.WriteString("    }\n\n")

	return sb.String()
}

func (g *SwiftGenerator) generateSwiftRowMapper(entity *parser.EntityDecl) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("    private func mapRow(_ stmt: OpaquePointer?) -> %s {\n", entity.Name))
	sb.WriteString(fmt.Sprintf("        %s(\n", entity.Name))

	var mapperLines []string
	for i, field := range entity.Fields {
		propertyName := ToCamelCase(field.Name)
		getter := g.swiftSQLiteGetter(field, i)
		mapperLines = append(mapperLines, fmt.Sprintf("            %s: %s", propertyName, getter))
	}
	sb.WriteString(strings.Join(mapperLines, ",\n"))
	sb.WriteString("\n        )\n")
	sb.WriteString("    }\n")

	return sb.String()
}

func (g *SwiftGenerator) generateQueryBuilder(file *parser.File) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by dataprotoc. DO NOT EDIT.\n\n")
	sb.WriteString("import Foundation\n\n")

	sb.WriteString("/// Type-safe query builder for DataProto entities\n")
	sb.WriteString("public struct QueryBuilder<T> {\n")
	sb.WriteString("    private var whereClauses: [String] = []\n")
	sb.WriteString("    private var orderByClauses: [String] = []\n")
	sb.WriteString("    private var limitValue: Int?\n")
	sb.WriteString("    private var parameters: [Any] = []\n\n")

	sb.WriteString("    public init() {}\n\n")

	sb.WriteString("    public func `where`(_ clause: String, _ params: Any...) -> QueryBuilder {\n")
	sb.WriteString("        var copy = self\n")
	sb.WriteString("        copy.whereClauses.append(clause)\n")
	sb.WriteString("        copy.parameters.append(contentsOf: params)\n")
	sb.WriteString("        return copy\n")
	sb.WriteString("    }\n\n")

	sb.WriteString("    public func orderBy(_ field: String, ascending: Bool = true) -> QueryBuilder {\n")
	sb.WriteString("        var copy = self\n")
	sb.WriteString("        copy.orderByClauses.append(\"\\(field) \\(ascending ? \"ASC\" : \"DESC\")\")\n")
	sb.WriteString("        return copy\n")
	sb.WriteString("    }\n\n")

	sb.WriteString("    public func limit(_ count: Int) -> QueryBuilder {\n")
	sb.WriteString("        var copy = self\n")
	sb.WriteString("        copy.limitValue = count\n")
	sb.WriteString("        return copy\n")
	sb.WriteString("    }\n\n")

	sb.WriteString("    public func build(table: String) -> (sql: String, parameters: [Any]) {\n")
	sb.WriteString("        var sql = \"SELECT * FROM \\(table)\"\n")
	sb.WriteString("        if !whereClauses.isEmpty {\n")
	sb.WriteString("            sql += \" WHERE \" + whereClauses.joined(separator: \" AND \")\n")
	sb.WriteString("        }\n")
	sb.WriteString("        if !orderByClauses.isEmpty {\n")
	sb.WriteString("            sql += \" ORDER BY \" + orderByClauses.joined(separator: \", \")\n")
	sb.WriteString("        }\n")
	sb.WriteString("        if let limit = limitValue {\n")
	sb.WriteString("            sql += \" LIMIT \\(limit)\"\n")
	sb.WriteString("        }\n")
	sb.WriteString("        return (sql, parameters)\n")
	sb.WriteString("    }\n")
	sb.WriteString("}\n")

	return sb.String()
}

// Helper methods

func (g *SwiftGenerator) swiftType(typeRef *parser.TypeRef) string {
	baseType := g.swiftBaseType(typeRef.Name)
	if typeRef.Optional {
		return baseType + "?"
	}
	return baseType
}

func (g *SwiftGenerator) swiftBaseType(typeName string) string {
	switch typeName {
	case "string":
		return "String"
	case "int32":
		return "Int32"
	case "int64", "timestamp":
		return "Int64"
	case "float":
		return "Float"
	case "double":
		return "Double"
	case "bool":
		return "Bool"
	case "bytes":
		return "Data"
	default:
		return typeName
	}
}

func (g *SwiftGenerator) swiftDefaultValue(value interface{}, typeName string) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("\"%s\"", v)
	case bool:
		return fmt.Sprintf("%t", v)
	case int64:
		return fmt.Sprintf("%d", v)
	case float64:
		return fmt.Sprintf("%f", v)
	default:
		return g.swiftDefaultForType(typeName)
	}
}

func (g *SwiftGenerator) swiftDefaultForType(typeName string) string {
	switch typeName {
	case "string":
		return "\"\""
	case "int32", "int64", "timestamp":
		return "0"
	case "float", "double":
		return "0.0"
	case "bool":
		return "false"
	case "bytes":
		return "Data()"
	default:
		return "nil"
	}
}

func (g *SwiftGenerator) protoGetter(field *parser.FieldDecl) string {
	propertyName := ToCamelCase(field.Name)

	if field.Type.Optional {
		return fmt.Sprintf("proto.has%s ? proto.%s : nil",
			ToPascalCase(field.Name), propertyName)
	}
	return "proto." + propertyName
}

func (g *SwiftGenerator) protoSetter(field *parser.FieldDecl, propertyName string) string {
	if field.Type.Optional {
		return fmt.Sprintf("if let val = %s { proto.%s = val }",
			propertyName, propertyName)
	}
	return fmt.Sprintf("proto.%s = %s", propertyName, propertyName)
}

func (g *SwiftGenerator) swiftSQLiteBinding(field *parser.FieldDecl, index int, value string) string {
	switch field.Type.Name {
	case "string":
		if field.Type.Optional {
			return fmt.Sprintf("if let v = %s { sqlite3_bind_text(stmt, %d, v, -1, nil) } else { sqlite3_bind_null(stmt, %d) }",
				value, index, index)
		}
		return fmt.Sprintf("sqlite3_bind_text(stmt, %d, %s, -1, nil)", index, value)
	case "int32":
		if field.Type.Optional {
			return fmt.Sprintf("if let v = %s { sqlite3_bind_int(stmt, %d, v) } else { sqlite3_bind_null(stmt, %d) }",
				value, index, index)
		}
		return fmt.Sprintf("sqlite3_bind_int(stmt, %d, %s)", index, value)
	case "int64", "timestamp":
		if field.Type.Optional {
			return fmt.Sprintf("if let v = %s { sqlite3_bind_int64(stmt, %d, v) } else { sqlite3_bind_null(stmt, %d) }",
				value, index, index)
		}
		return fmt.Sprintf("sqlite3_bind_int64(stmt, %d, %s)", index, value)
	case "double", "float":
		if field.Type.Optional {
			return fmt.Sprintf("if let v = %s { sqlite3_bind_double(stmt, %d, Double(v)) } else { sqlite3_bind_null(stmt, %d) }",
				value, index, index)
		}
		return fmt.Sprintf("sqlite3_bind_double(stmt, %d, Double(%s))", index, value)
	case "bool":
		return fmt.Sprintf("sqlite3_bind_int(stmt, %d, %s ? 1 : 0)", index, value)
	default:
		return fmt.Sprintf("sqlite3_bind_text(stmt, %d, String(describing: %s), -1, nil)", index, value)
	}
}

func (g *SwiftGenerator) swiftSQLiteBindingByType(typeName string, index int, value string) string {
	switch typeName {
	case "string":
		return fmt.Sprintf("sqlite3_bind_text(stmt, %d, %s, -1, nil)", index, value)
	case "int32":
		return fmt.Sprintf("sqlite3_bind_int(stmt, %d, %s)", index, value)
	case "int64", "timestamp":
		return fmt.Sprintf("sqlite3_bind_int64(stmt, %d, %s)", index, value)
	case "double", "float":
		return fmt.Sprintf("sqlite3_bind_double(stmt, %d, Double(%s))", index, value)
	case "bool":
		return fmt.Sprintf("sqlite3_bind_int(stmt, %d, %s ? 1 : 0)", index, value)
	default:
		return fmt.Sprintf("sqlite3_bind_text(stmt, %d, String(describing: %s), -1, nil)", index, value)
	}
}

func (g *SwiftGenerator) swiftSQLiteGetter(field *parser.FieldDecl, index int) string {
	switch field.Type.Name {
	case "string":
		base := fmt.Sprintf("String(cString: sqlite3_column_text(stmt, %d))", index)
		if field.Type.Optional {
			return fmt.Sprintf("sqlite3_column_type(stmt, %d) != SQLITE_NULL ? %s : nil", index, base)
		}
		return base
	case "int32":
		base := fmt.Sprintf("sqlite3_column_int(stmt, %d)", index)
		if field.Type.Optional {
			return fmt.Sprintf("sqlite3_column_type(stmt, %d) != SQLITE_NULL ? %s : nil", index, base)
		}
		return base
	case "int64", "timestamp":
		base := fmt.Sprintf("sqlite3_column_int64(stmt, %d)", index)
		if field.Type.Optional {
			return fmt.Sprintf("sqlite3_column_type(stmt, %d) != SQLITE_NULL ? %s : nil", index, base)
		}
		return base
	case "double":
		base := fmt.Sprintf("sqlite3_column_double(stmt, %d)", index)
		if field.Type.Optional {
			return fmt.Sprintf("sqlite3_column_type(stmt, %d) != SQLITE_NULL ? %s : nil", index, base)
		}
		return base
	case "float":
		base := fmt.Sprintf("Float(sqlite3_column_double(stmt, %d))", index)
		if field.Type.Optional {
			return fmt.Sprintf("sqlite3_column_type(stmt, %d) != SQLITE_NULL ? %s : nil", index, base)
		}
		return base
	case "bool":
		return fmt.Sprintf("sqlite3_column_int(stmt, %d) != 0", index)
	default:
		return fmt.Sprintf("String(cString: sqlite3_column_text(stmt, %d))", index)
	}
}
